<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference ¬∑ Pioran.jl</title><meta name="title" content="API Reference ¬∑ Pioran.jl"/><meta property="og:title" content="API Reference ¬∑ Pioran.jl"/><meta property="twitter:title" content="API Reference ¬∑ Pioran.jl"/><meta name="description" content="Pioran.jl: A Julia package for power spectral density estimation using scalable Gaussian processes."/><meta property="og:description" content="Pioran.jl: A Julia package for power spectral density estimation using scalable Gaussian processes."/><meta property="twitter:description" content="Pioran.jl: A Julia package for power spectral density estimation using scalable Gaussian processes."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Pioran.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pioran.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">Basic usage</span><ul><li><a class="tocitem" href="../explanation/">Spectral analysis in Pioran</a></li><li><a class="tocitem" href="../modelling/">Modelling</a></li><li><a class="tocitem" href="../simulations/">Simulations</a></li><li><a class="tocitem" href="../timeseries/">Time series and priors</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics post-inference</a></li><li><a class="tocitem" href="../basis_functions/">About the basis functions</a></li></ul></li><li><span class="tocitem">Inference</span><ul><li><a class="tocitem" href="../turing/">Hamiltonian Monte Carlo with Turing.jl</a></li><li><a class="tocitem" href="../ultranest/">Nested sampling with ultranest</a></li></ul></li><li><span class="tocitem">Advanced modelling</span><ul><li><a class="tocitem" href="../custom_mean/">Using custom mean function</a></li><li><a class="tocitem" href="../adding_features/">Modelling features in the power spectrum</a></li></ul></li><li><a class="tocitem" href="../carma/">CARMA</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Power-spectral-densities"><span>Power spectral densities</span></a></li><li><a class="tocitem" href="#Covariance-functions"><span>Covariance functions</span></a></li><li><a class="tocitem" href="#Gaussian-processes"><span>Gaussian processes</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#CARMA"><span>CARMA</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mlefkir/Pioran.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mlefkir/Pioran.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Power-spectral-densities"><a class="docs-heading-anchor" href="#Power-spectral-densities">Power spectral densities</a><a id="Power-spectral-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Power-spectral-densities" title="Permalink"></a></h2><h3 id="Models-and-functions"><a class="docs-heading-anchor" href="#Models-and-functions">Models and functions</a><a id="Models-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Models-and-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.approx" href="#Pioran.approx"><code>Pioran.approx</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approx(psd_model, f_min, f_max, n_components=20, norm=1.0,S_low::Real=20., S_high::Real=20. ; is_integrated_power::Bool = true, basis_function=&quot;SHO&quot;)</code></pre><p>Approximate the PSD with a sum of basis functions to form a covariance function. The PSD model is approximated between <code>f0=f_min/S_low</code> and <code>fM=f_min*S_high</code>. By default it is normalised by its integral from <code>f_min</code> to <code>f_max</code> but it can also be normalised by its integral from 0 to infinity using the <code>variance</code> argument.</p><p><strong>Arguments</strong></p><ul><li><code>psd_model::PowerSpectralDensity</code>: model of the PSD</li><li><code>f_min::Real</code>: the minimum frequency in the time series</li><li><code>f_max::Real</code>: the maximum frequency in the time series</li><li><code>n_components::Integer=20</code>: the number of basis functions to use</li><li><code>norm::Real=1.0</code>: normalisation of the PSD.</li><li><code>S_low::Real=20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high::Real=20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>is_integrated_power::Bool = true</code>: if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code>, if not it is the variance of the process, integral of the PSD from 0 to +inf.</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li></ul><p><strong>Return</strong></p><ul><li><code>covariance::SumOfSemiSeparable</code>: the covariance function</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Pioran
ùìü = SingleBendingPowerLaw(1.0, 1.0, 2.0)
ùì° = approx(ùìü, 1e-4, 1e-1, 30, 2.31,basis_function=&quot;SHO&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L188-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_covariance_from_psd-Tuple{Any}" href="#Pioran.get_covariance_from_psd-Tuple{Any}"><code>Pioran.get_covariance_from_psd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_covariance_from_psd(psd_features)</code></pre><p>Get the covariance function from the PSD features</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.DoubleBendingPowerLaw" href="#Tonari.DoubleBendingPowerLaw"><code>Tonari.DoubleBendingPowerLaw</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> DoubleBendingPowerLaw(A, Œ±‚ÇÅ, f‚ÇÅ, Œ±‚ÇÇ, f‚ÇÇ, Œ±‚ÇÉ)</code></pre><p>Double bending power law model for the power spectral density</p><ul><li><code>A</code> : the amplitude</li><li><code>Œ±‚ÇÅ</code>: the first power law index</li><li><code>f‚ÇÅ</code>: the first bend frequency</li><li><code>Œ±‚ÇÇ</code>: the second power law index</li><li><code>f‚ÇÇ</code>: the second bend frequency</li><li><code>Œ±‚ÇÉ</code>: the third power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  A\frac{(f/f‚ÇÅ)^{-Œ±‚ÇÅ}}{1 + (f / f‚ÇÅ)^{Œ±‚ÇÇ - Œ±‚ÇÅ}}\frac{1}{1 + (f / f‚ÇÇ)^{Œ±‚ÇÉ - Œ±‚ÇÇ}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/v0.2.0/src/psd.jl#L70-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.Lorentzian" href="#Tonari.Lorentzian"><code>Tonari.Lorentzian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lorentzian(A, Œ≥, f‚ÇÄ)</code></pre><p>Lorentzian model for the power spectral density</p><ul><li><code>A</code>: the amplitude</li><li><code>Œ≥</code>: the width of the peak</li><li><code>f‚ÇÄ</code>: the central frequency</li></ul><p class="math-container">\[\mathcal{P}(f) =  \frac{A}{4\pi^2 (f - f‚ÇÄ)^2 + Œ≥^2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/v0.2.0/src/psd.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.PowerLaw" href="#Tonari.PowerLaw"><code>Tonari.PowerLaw</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> PowerLaw(Œ±)</code></pre><p>Power law model for the power spectral density</p><ul><li><code>Œ±</code>: the power law index</li></ul><p class="math-container">\[\mathcal{P}(f) = A f^{-Œ±}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/v0.2.0/src/psd.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.QPO" href="#Tonari.QPO"><code>Tonari.QPO</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QPO(S‚ÇÄ, f‚ÇÄ,A Q)</code></pre><p>QPO model</p><ul><li><code>S‚ÇÄ</code>: the amplitude at the peak</li><li><code>f‚ÇÄ</code>: the central frequency</li><li><code>Q</code>: quality factor</li></ul><p class="math-container">\[\mathcal{P}(f) =  \frac{S_0 {f_0}^4 } {\left(f^ 2 -{f_0}^2\right)^ 2 + f^2 {f_0}^2 /  Q^2 }\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/v0.2.0/src/psd.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.SingleBendingPowerLaw" href="#Tonari.SingleBendingPowerLaw"><code>Tonari.SingleBendingPowerLaw</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SingleBendingPowerLaw(A, Œ±‚ÇÅ, f‚ÇÅ, Œ±‚ÇÇ)</code></pre><p>Single bending power law model for the power spectral density</p><ul><li><code>A</code>: the amplitude</li><li><code>Œ±‚ÇÅ</code>: the first power law index</li><li><code>f‚ÇÅ</code>: the first bend frequency</li><li><code>Œ±‚ÇÇ</code>: the second power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  A \frac{(f/f‚ÇÅ)^{-Œ±‚ÇÅ}}{1 + (f / f‚ÇÅ)^{Œ±‚ÇÇ - Œ±‚ÇÅ}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/v0.2.0/src/psd.jl#L47-L60">source</a></section></article><h3 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.approximated_psd-Tuple{Any, PowerSpectralDensity, Real, Real}" href="#Pioran.approximated_psd-Tuple{Any, PowerSpectralDensity, Real, Real}"><code>Pioran.approximated_psd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> approximated_psd(f, psd_model, f0, fM; n_components=20, norm=1.0, basis_function=&quot;SHO&quot;)</code></pre><p>Return the approximated PSD. This is essentially to check that the model and the approximation are consistent.</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractVector{&lt;:Real}</code>: the frequencies at which to evaluate the PSD</li><li><code>psd_model::PowerSpectralDensity</code>: model of the PSD</li><li><code>f0::Real</code>: the lowest frequency</li><li><code>fM::Real</code>: the highest frequency</li><li><code>n_components::Integer=20</code>: the number of basis functions to use</li><li><code>norm::Real=1.0</code>: normalisation of the PSD</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li><li><code>individual::Bool=false</code>: return the individual components</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L138-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.build_approx-Tuple{Int64, Real, Real}" href="#Pioran.build_approx-Tuple{Int64, Real, Real}"><code>Pioran.build_approx</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> build_approx(J, f0, fM; basis_function=&quot;SHO&quot;)</code></pre><p>Prepare the approximation of a PSD</p><p><strong>Arguments</strong></p><ul><li><code>J::Integer</code>: the number of basis functions</li><li><code>f0::Real</code>: the lowest frequency</li><li><code>fM::Real</code>: the highest frequency</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li></ul><p><strong>Return</strong></p><ul><li><code>spectral_points::Vector{Real}</code>: the spectral points</li><li><code>spectral_matrix::Matrix{Real}</code>: the spectral matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L59-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.convert_feature-Tuple{PowerSpectralDensity}" href="#Pioran.convert_feature-Tuple{PowerSpectralDensity}"><code>Pioran.convert_feature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> convert_feature(psd_feature)</code></pre><p>Convert a PSD feature to a Celerite covariance function Only QPO is implemented</p><p><strong>Arguments</strong></p><ul><li><code>psd_feature::PowerSpectralDensity</code>: the PSD feature</li></ul><p><strong>Return</strong></p><ul><li><code>covariance::SemiSeparable</code>: the covariance function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_approx_coefficients-Tuple{PowerSpectralDensity, Real, Real}" href="#Pioran.get_approx_coefficients-Tuple{PowerSpectralDensity, Real, Real}"><code>Pioran.get_approx_coefficients</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_approx_coefficients(psd_model, f0, fM; n_components=20, basis_function=&quot;SHO&quot;)</code></pre><p>Get the coefficients of the approximated PSD</p><p><strong>Arguments</strong></p><ul><li><code>psd_model::PowerSpectralDensity</code>: model of the PSD</li><li><code>f0::Real</code>: the lowest frequency</li><li><code>fM::Real</code>: the highest frequency</li><li><code>n_components::Integer=20</code>: the number of basis functions to use</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li></ul><p><strong>Return</strong></p><ul><li><code>amplitudes::Vector{Real}</code>: the amplitudes of the basis functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_norm_psd" href="#Pioran.get_norm_psd"><code>Pioran.get_norm_psd</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_norm_psd(amplitudes,spectral_points,f_min,f_max,basis_function,is_integrated_power, cov_features=nothing)</code></pre><p>Get the normalisation of the sum of basis functions.</p><p><strong>Arguments</strong></p><ul><li><code>amplitudes</code>: amplitude of the basis function</li><li><code>spectral_points</code>: spectral points of the basis function</li><li><code>f_min::Real</code>: the minimum frequency in the time series</li><li><code>f_max::Real</code>: the maximum frequency in the time series</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li><li><code>is_integrated_power::Bool=true</code>: if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>cov_features</code>: PSD features of the PSD, is nothing if there are no features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L361-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_normalised_psd-Tuple{PowerSpectralDensity, AbstractVector{&lt;:Real}}" href="#Pioran.get_normalised_psd-Tuple{PowerSpectralDensity, AbstractVector{&lt;:Real}}"><code>Pioran.get_normalised_psd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_normalised_psd(psd_model::PowerSpectralDensity, spectral_points::AbstractVector{&lt;:Real})</code></pre><p>Get the PSD normalised at the lowest frequency</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integral_celerite-NTuple{5, Any}" href="#Pioran.integral_celerite-NTuple{5, Any}"><code>Pioran.integral_celerite</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integral_celerite(a, b, c, d, x)</code></pre><p>Computes the integral of the Celerite power spectrum:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L327-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integral_drwcelerite-Tuple{Any, Any, Any}" href="#Pioran.integral_drwcelerite-Tuple{Any, Any, Any}"><code>Pioran.integral_drwcelerite</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integral_drwcelerite(a, c, x)</code></pre><p>Computes the integral of the DRWCelerite basis function of amplitude <code>a</code> and width <code>c</code> for a given <code>x</code>.</p><p>The DRWCelerite basis function is defined as:</p><p class="math-container">\[    \int \dfrac{a\, {d}x}{(x/c)^6+1} =\dfrac{ac}{3} \left[ \arctan{(x/c)} +\dfrac{\sqrt3}{4}\ln{\left(\dfrac{x^2+xc\sqrt3+c^2}{x^2-xc\sqrt3+c^2}\right)}+\dfrac{1}{2}\arctan{\left(\dfrac{x^2-c^2}{xc}\right)}\right]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L308-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integral_sho-Tuple{Any, Any, Any}" href="#Pioran.integral_sho-Tuple{Any, Any, Any}"><code>Pioran.integral_sho</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integral_sho(a, c, x)</code></pre><p>Computes the integral of the SHO basis function of amplitude a and width c for a given x.</p><p>This integral is obtained using Equation: 4.2.7.1.3 from the &quot;Handbook of Mathematical Formulas and Integrals&quot; 2009</p><p class="math-container">\[    \int \dfrac{a\, {d}x}{(x/c)^4+1} =\dfrac{ac}{4\sqrt2} \left[\ln{\left(\dfrac{x^2+cx\sqrt2+c^2}{x^2-cx\sqrt2+c^2}\right)}+2\arctan{\left(\dfrac{cx\sqrt2}{c^2-x^2}\right)}\right]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L292-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integrate_basis_function-NTuple{5, Any}" href="#Pioran.integrate_basis_function-NTuple{5, Any}"><code>Pioran.integrate_basis_function</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_basis_function(a,c,x‚ÇÅ,x‚ÇÇ,basis_function)</code></pre><p>Computes the integral of the basis function between x‚ÇÅ and x‚ÇÇ for a given amplitude a and width c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integrate_psd_feature-NTuple{6, Any}" href="#Pioran.integrate_psd_feature-NTuple{6, Any}"><code>Pioran.integrate_psd_feature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_psd_feature(a, b, c, d, x‚ÇÅ, x‚ÇÇ)</code></pre><p>Computes the integral of a celerite power spectral density with coefficients (a,b,c,d) between x‚ÇÅ and x‚ÇÇ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L352-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.psd_decomp-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#Pioran.psd_decomp-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>Pioran.psd_decomp</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> psd_decomp(psd_normalised, spectral_matrix)</code></pre><p>Get amplitudes of the basis functions by solving the linear system of the approximation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/psd.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tonari.separate_psd-Tuple{PowerSpectralDensity}" href="#Tonari.separate_psd-Tuple{PowerSpectralDensity}"><code>Tonari.separate_psd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> separate_psd(psd::PowerSpectralDensity)</code></pre><p>Separate the PSD into its BendingPowerLaw components and other components if it is a sum of PSDs</p><p><strong>Arguments</strong></p><ul><li><code>psd::PowerSpectralDensity</code>: power spectral density or sum of PowerSpectralDensity objects</li></ul><p><strong>Return</strong></p><ul><li><code>psd_continuum::Union{SumOfPowerSpectralDensity,PowerSpectralDensity,nothing}</code>: continuum part of the psd</li><li><code>psd_line::Union{PowerSpectralDensity,nothing,Vector{PowerSpectralDensity}}</code>: non-continuum part of the psd</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Tonari.jl/blob/v0.2.0/src/psd.jl#L165-L176">source</a></section></article><h2 id="Covariance-functions"><a class="docs-heading-anchor" href="#Covariance-functions">Covariance functions</a><a id="Covariance-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-functions" title="Permalink"></a></h2><h3 id="Models-and-functions-2"><a class="docs-heading-anchor" href="#Models-and-functions-2">Models and functions</a><a class="docs-heading-anchor-permalink" href="#Models-and-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.Exp" href="#Pioran.Exp"><code>Pioran.Exp</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Exp(A, Œ±)</code></pre><p>Exponential covariance Function</p><ul><li><code>A</code>: the amplitude of the covariance function</li><li><code>Œ±</code>: the decay rate of the covariance function</li></ul><p class="math-container">\[k(œÑ) = A \exp(-Œ± œÑ)\]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Exp(1.0, 0.25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/Exp.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.evaluate-Tuple{Exp, Any}" href="#Pioran.evaluate-Tuple{Exp, Any}"><code>Pioran.evaluate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>evaluate(R::Exp, f)</p><pre><code class="nohighlight hljs">This is the right formula but it disagrees with the Celerite implementation...

Evaluate the power spectral density at frequency f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/Exp.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.SHO" href="#Pioran.SHO"><code>Pioran.SHO</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SHO(A, œâ‚ÇÄ, Q)</code></pre><p>Simple Harmonic Oscillator covariance Function</p><ul><li><code>A</code>: the amplitude of the covariance function</li><li><code>œâ‚ÇÄ</code>: the angular frequency of the simple harmonic oscillator</li><li><code>Q</code>: the quality factor of the simple harmonic oscillator</li></ul><p class="math-container">\[k(œÑ) = A \exp(-œâ‚ÇÄ œÑ / Q / 2) \left\{\begin{matrix} 2(1 + œâ‚ÇÄ œÑ) &amp; Q = 1/2 \\ \cos(Œ∑ œâ‚ÇÄ œÑ) + \frac{\sin(Œ∑ œâ‚ÇÄ œÑ)}{2Œ∑ Q} &amp; Q &lt; 1/2 \\ \cosh(Œ∑ œâ‚ÇÄ œÑ) + \frac{\sinh(Œ∑ œâ‚ÇÄ œÑ)}{2Œ∑ Q} &amp; Q \geq 1/2 \end{matrix}\right.\\
Œ∑ = \sqrt{\left|1 - \frac{1}{4 Q^2}\right|}\]</p><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/SHO.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.Celerite" href="#Pioran.Celerite"><code>Pioran.Celerite</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Celerite(a, b, c, d)</code></pre><p>Celerite covariance Function</p><ul><li><code>a</code>: the amplitude of the first term</li><li><code>b</code>: the amplitude of the second term</li><li><code>c</code>: the decay rate of the covariance function</li><li><code>d</code>: the <code>period</code> of the covariance function</li></ul><p class="math-container">\[k(œÑ) = \exp(-c œÑ) (a \cos(d œÑ) + b \sin(d œÑ))\]</p><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/Celerite.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.evaluate-Tuple{Celerite, Any}" href="#Pioran.evaluate-Tuple{Celerite, Any}"><code>Pioran.evaluate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>evaluate(f, C::Celerite)</p><pre><code class="nohighlight hljs">evaluate the power spectral density at frequency f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/Celerite.jl#L53-L57">source</a></section></article><h3 id="Helper-functions-2"><a class="docs-heading-anchor" href="#Helper-functions-2">Helper functions</a><a class="docs-heading-anchor-permalink" href="#Helper-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Pioran.SemiSeparable, Pioran.SemiSeparable}" href="#Base.:+-Tuple{Pioran.SemiSeparable, Pioran.SemiSeparable}"><code>Base.:+</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> +(::SemiSeparable, ::SemiSeparable)

Sum of semi-separable covariance functions</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/acvf.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.celerite_coefs-Tuple{Pioran.SumOfSemiSeparable}" href="#Pioran.celerite_coefs-Tuple{Pioran.SumOfSemiSeparable}"><code>Pioran.celerite_coefs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> celerite_coefs(covariance)

Get the celerite coefficients</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/acvf.jl#L113-L117">source</a></section></article><h2 id="Gaussian-processes"><a class="docs-heading-anchor" href="#Gaussian-processes">Gaussian processes</a><a id="Gaussian-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.ScalableGP" href="#Pioran.ScalableGP"><code>Pioran.ScalableGP</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalableGP(Œº, ùì°; solver=:celerite)</code></pre><p>Scalable Gaussian Process for semi-separable covariance functions.</p><ul><li><code>Œº</code> : mean or mean function of the Gaussian Process</li><li><code>ùì°</code> : covariance function</li><li><code>solver</code> : indicates which solver to use for the likelihood computation.</li></ul><p>A scalable Gaussian process has a covariance function formed of semi-separable kernels</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Pioran
ùìü = SingleBendingPowerLaw(1.0, 1.0, 2.0)
ùì° = approx(ùìü, 1e-4, 1e-1, 30, 2.31,basis_function=&quot;SHO&quot;)
Œº = 1.2

f = ScalableGP(ùì°) # zero-mean GP
f = ScalableGP(Œº, ùì°) # with mean Œº</code></pre><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(rng::AbstractRNG, fp::PosteriorGP, N::Int=1)
rand(rng::AbstractRNG, fp::PosteriorGP, œÑ::AbstractVecOrMat{&lt;:Real}, N::Int=1)
rand(fp::PosteriorGP, N::Int=1)</code></pre><p>Sample <code>N</code> realisations from the posterior GP <code>fp</code> at the points <code>œÑ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, AbstractGPs.FiniteGP{&lt;:ScalableGP}}" href="#Base.rand-Tuple{Random.AbstractRNG, AbstractGPs.FiniteGP{&lt;:ScalableGP}}"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(rng::AbstractRNG, f::ScalableGP)
rand(rng::AbstractRNG, f::ScalableGP, t::AbstractVecOrMat{&lt;:Real})
rand(f::ScalableGP)
rand(f::ScalableGP, t::AbstractVecOrMat{&lt;:Real})</code></pre><p>Draw a realisation from the GP <code>f</code> at the points <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}" href="#Distributions.logpdf-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}"><code>Distributions.logpdf</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logpdf(f::ScalableGP, Y::AbstractVecOrMat{&lt;:Real})</code></pre><p>Compute the log-likelihood of the data Y given the GP f.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran._predict_cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Pioran._predict_cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Pioran._predict_cov</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_predict_cov(fp::PosteriorGP, œÑ::AbstractVecOrMat{&lt;:Real})
Compute the posterior covariance of the GP at the points œÑ.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L69-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran._predict_mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Pioran._predict_mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Pioran._predict_mean</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_predict_mean(fp::PosteriorGP, œÑ::AbstractVecOrMat{&lt;:Real})

Compute the Posterior mean of the GP at the points œÑ.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.posterior-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}" href="#Pioran.posterior-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}"><code>Pioran.posterior</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">posterior(f::ScalableGP, y::AbstractVecOrMat{&lt;:Real})</code></pre><p>Compute the posterior Gaussian process <code>fp</code> given the GP <code>f</code> and the data <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Statistics.cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Statistics.cov</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cov(fp::PosteriorGP, œÑ::AbstractVecOrMat{&lt;:Real})
cov(fp::PosteriorGP)</code></pre><p>Compute the covariance of the posterior GP at the points œÑ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Statistics.mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Statistics.mean</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean(fp::PosteriorGP, œÑ::AbstractVecOrMat{&lt;:Real})
mean(fp::PosteriorGP)</code></pre><p>Compute the mean of the posterior GP at the points œÑ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Tuple{Pioran.PosteriorGP}" href="#Statistics.std-Tuple{Pioran.PosteriorGP}"><code>Statistics.std</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">std(fp::PosteriorGP, œÑ::AbstractVecOrMat{&lt;:Real})
std(fp::PosteriorGP)</code></pre><p>Compute the standard deviation of the posterior GP at the points œÑ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/scalable_GP.jl#L97-L102">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><h3 id="Celerite-solver"><a class="docs-heading-anchor" href="#Celerite-solver">Celerite solver</a><a id="Celerite-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Celerite-solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.compute_nll-NTuple{7, Any}" href="#Pioran.compute_nll-NTuple{7, Any}"><code>Pioran.compute_nll</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_nll(t, y, œÉ¬≤, a, b, c, d)

Compute the likelihood using the vectorised implementation in `get_values!`.

Still experimental.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_values!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}" href="#Pioran.get_values!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}"><code>Pioran.get_values!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_values!(a, b, c, d, zp, U, V, P, D, t)</code></pre><p>Compute the values of the matrices and vectors needed for the celerite algorithm. This is a vectorised version of the <code>init_semi_separable!</code> and <code>solve_prec!</code> functions. This function appears to be faster than the two previous functions when J &gt; 16 but it also uses more memory.</p><p>More study of this implementation is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.log_likelihood-Tuple{Pioran.SumOfCelerite, Any, Any, Any}" href="#Pioran.log_likelihood-Tuple{Pioran.SumOfCelerite, Any, Any, Any}"><code>Pioran.log_likelihood</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log_likelihood(cov, œÑ, y, œÉ2; solver = :celerite)</code></pre><p>Compute the log-likelihood of a semi-separable covariance function using the celerite algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>cov::SumOfSemiSeparable</code> or <code>cov::CARMA</code> or <code>cov::SemiSeparable</code>: the covariance function</li><li><code>œÑ::Vector</code>: the time points</li><li><code>y::Vector</code>: the data</li><li><code>œÉ2::Vector</code>: the measurement variances</li><li><code>solver::Symbol</code>: solver to use for the likelihood computation either <code>:celerite</code> for the classic celerite solver or <code>:celerite_matrix</code> for the solver using matrices algebra.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L249-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.logl-NTuple{7, Any}" href="#Pioran.logl-NTuple{7, Any}"><code>Pioran.logl</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logl(a, b, c, d, œÑ, y, œÉ2)</code></pre><p>Compute the log-likelihood of a GP with a semi-separable covariance function using the celerite algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>a::Vector</code></li><li><code>b::Vector</code></li><li><code>c::Vector</code></li><li><code>d::Vector</code></li><li><code>œÑ::Vector</code>: the time points</li><li><code>y::Vector</code>: the data</li><li><code>œÉ2::Vector</code>: the measurement variances</li></ul><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L296-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.predict-Tuple{Pioran.SumOfSemiSeparable, Vararg{AbstractVector, 4}}" href="#Pioran.predict-Tuple{Pioran.SumOfSemiSeparable, Vararg{AbstractVector, 4}}"><code>Pioran.predict</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(cov, œÑ, t, y, œÉ2)</code></pre><p>Compute the posterior mean of the GP at the points œÑ given the data y and time t.</p><p><strong>Arguments</strong></p><ul><li><code>cov::SumOfSemiSeparable</code> or <code>cov::CARMA</code> or <code>cov::SemiSeparable</code>: the covariance function</li><li><code>œÑ::Vector</code>: the time points</li><li><code>t::Vector</code>: the data time points</li><li><code>y::Vector</code>: the data</li><li><code>œÉ2::Vector</code>: the measurement variances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L336-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.simulate-Tuple{Random.AbstractRNG, Pioran.SumOfSemiSeparable, AbstractVector, AbstractVector}" href="#Pioran.simulate-Tuple{Random.AbstractRNG, Pioran.SumOfSemiSeparable, AbstractVector, AbstractVector}"><code>Pioran.simulate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(rng, cov, œÑ, œÉ2)
simulate(cov, œÑ, œÉ2)</code></pre><p>Draw a realisation from the  GP with the covariance function cov at the points œÑ with the variances œÉ2.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: the random number generator</li><li><code>cov::SumOfSemiSeparable</code> or <code>cov::CARMA</code> or <code>cov::SemiSeparable</code>: the covariance function</li><li><code>œÑ::Vector</code>: the time points</li><li><code>œÉ2::Vector</code>: the measurement variances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L485-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.solve_prec!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}" href="#Pioran.solve_prec!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}"><code>Pioran.solve_prec!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_prec!(z, y, U, W, D, œï)</code></pre><p>Forward and backward substitution of the celerite algorithm.</p><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/celerite_solver.jl#L108-L114">source</a></section></article><h3 id="Direct-solver"><a class="docs-heading-anchor" href="#Direct-solver">Direct solver</a><a id="Direct-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.log_likelihood_direct-Tuple{KernelFunctions.SimpleKernel, Vector, Vector, Vector}" href="#Pioran.log_likelihood_direct-Tuple{KernelFunctions.SimpleKernel, Vector, Vector, Vector}"><code>Pioran.log_likelihood_direct</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log_likelihood_direct(cov::KernelFunctions.SimpleKernel, t::Vector, y::Vector, œÉ¬≤::Vector)

Compute the log-likelihood of the data Y given the GP f with the direct solver.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/direct_solver.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.predict_cov-Tuple{KernelFunctions.SimpleKernel, AbstractVector, AbstractVector, AbstractVector}" href="#Pioran.predict_cov-Tuple{KernelFunctions.SimpleKernel, AbstractVector, AbstractVector, AbstractVector}"><code>Pioran.predict_cov</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_direct(cov::KernelFunctions.SimpleKernel, œÑ::AbstractVector, t::AbstractVector, œÉ¬≤::AbstractVector)

Compute the posterior covariance of the GP at the points œÑ given the times t and the noise variance œÉ¬≤.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/direct_solver.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.predict_direct" href="#Pioran.predict_direct"><code>Pioran.predict_direct</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_direct(cov::KernelFunctions.SimpleKernel, œÑ::AbstractVector, t::AbstractVector, y::AbstractVector, œÉ¬≤::AbstractVector, with_covariance::Bool=false)

Compute the posterior mean of the GP at the points œÑ given the data (t, y) and the noise variance œÉ¬≤.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/direct_solver.jl#L70-L74">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><h3 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.run_diagnostics" href="#Pioran.run_diagnostics"><code>Pioran.run_diagnostics</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_diagnostics(prior_samples, norm_samples, f_min, f_max, model, S_low=20.0, S_high=20.0; path=&quot;&quot;, basis_function=&quot;SHO&quot;, n_components=20)</code></pre><p>Run the prior predictive checks for the model and the approximation of the PSD</p><p><strong>Arguments</strong></p><ul><li><code>prior_samples::Array{Float64, 2}</code> : Model samples from the prior distribution</li><li><code>norm_samples::Array{Float64, 1}</code> : The samples of the normalisation of the PSD</li><li><code>f_min::Float64</code> : The minimum frequency of the observed data</li><li><code>f_max::Float64</code> : The maximum frequency of the observed data</li><li><code>model::Function</code> : The model</li><li><code>S_low::Float64=20.0</code> : the scaling factor for the appoximation at low frequencies</li><li><code>S_high::Float64=20.0</code> : the scaling factor for the appoximation at high frequencies</li><li><code>path::String=&quot;&quot;</code> : The path to save the plots</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L215-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.run_posterior_predict_checks-NTuple{9, Any}" href="#Pioran.run_posterior_predict_checks-NTuple{9, Any}"><code>Pioran.run_posterior_predict_checks</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_posterior_predict_checks(samples, paramnames, t, y, yerr, model, with_log_transform; S_low = 20, S_high = 20, is_integrated_power = true, plots = &quot;all&quot;, n_samples = 100, path = &quot;&quot;, basis_function = &quot;SHO&quot;, n_frequencies = 1000, plot_f_P = false, n_components = 20)</code></pre><p>Run the posterior predictive checks for the model and the approximation of the PSD</p><p><strong>Arguments</strong></p><ul><li><code>samples::Array{Float64, 2}</code> : The samples from the posterior distribution</li><li><code>paramnames::Array{String, 1}</code> : The names of the parameters</li><li><code>t::Array{Float64, 1}</code> : The time series</li><li><code>y::Array{Float64, 1}</code> : The values of the time series</li><li><code>yerr::Array{Float64, 1}</code> : The errors of the time series</li><li><code>model::Function</code> : The model or a string representing the model</li><li><code>with_log_transform::Bool</code> : If true, the flux is log-transformed</li><li><code>S_low::Float64=20.0</code> : the scaling factor for the appoximation at low frequencies</li><li><code>S_high::Float64=20.0</code> : the scaling factor for the appoximation at high frequencies</li><li><code>plots::String or Array{String, 1}</code> : The type of plots to make. It can be &quot;all&quot;, &quot;psd&quot;, &quot;lsp&quot;, &quot;timeseries&quot; or a combination of them in an array</li><li><code>n_samples::Int=200</code> : The number of samples to draw from the posterior predictive distribution</li><li><code>path::String=&quot;all&quot;</code> : The path to save the plots</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>is_integrated_power = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>n_frequencies::Int=1000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>plot_f_P::Bool=false</code> : If true, the plots are made in terms of f * PSD</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L243-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.sample_approx_model-NTuple{5, Any}" href="#Pioran.sample_approx_model-NTuple{5, Any}"><code>Pioran.sample_approx_model</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_approx_model(samples, norm_samples, f0, fM, model; n_frequencies=1_000, basis_function=&quot;SHO&quot;, n_components=20)</code></pre><p>Check the approximation of the PSD by computing the residuals and the ratios of the PSD and the approximated PSD</p><p><strong>Arguments</strong></p><ul><li><code>samples::Array{Float64, n}</code> : The model samples</li><li><code>norm_samples::Array{Float64, 1}</code> : The normalisation samples</li><li><code>f0::Float64</code> : The minimum frequency for the approximation of the PSD</li><li><code>fM::Float64</code> : The maximum frequency for the approximation of the PSD</li><li><code>model::Function</code> : The model</li><li><code>n_frequencies::Int=1_000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li><li><code>is_integrated_power=true</code>: Does the normalisation correspond to the integral of the PSD between two frequencies? If false, it corresponds to the true variance of the process.</li></ul><p><strong>Return</strong></p><ul><li><code>psd::Array{Float64, 2}</code> : The PSD</li><li><code>psd_approx::Array{Float64, 2}</code> : The approximated PSD</li><li><code>residuals::Array{Float64, 2}</code> : The residuals (psd-approx_psd)</li><li><code>ratios::Array{Float64, 2}</code> : The ratios (approx_psd/psd)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L172-L194">source</a></section></article><h3 id="Individual-plotting-functions"><a class="docs-heading-anchor" href="#Individual-plotting-functions">Individual plotting functions</a><a id="Individual-plotting-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-plotting-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_ppc_timeseries-NTuple{7, Any}" href="#Pioran.get_ppc_timeseries-NTuple{7, Any}"><code>Pioran.get_ppc_timeseries</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ppc_timeseries(samples, t, y, yerr, GP_model, with_log_transform; t_pred = nothing, n_samples = 1000)</code></pre><p>Get the random posterior predictive time series from the model and samples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L626-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_boxplot_psd_approx-Tuple{Any, Any}" href="#Pioran.plot_boxplot_psd_approx-Tuple{Any, Any}"><code>Pioran.plot_boxplot_psd_approx</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_boxplot_psd_approx(residuals, ratios; path=&quot;&quot;)</code></pre><p>Plot the boxplot of the residuals and ratios for the PSD approximation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_lsp_ppc-NTuple{5, Any}" href="#Pioran.plot_lsp_ppc-NTuple{5, Any}"><code>Pioran.plot_lsp_ppc</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_lsp_ppc(samples, t, y, yerr, GP_model; plot_f_P=false, n_frequencies=1000, n_samples=1000, is_integrated_power = true, n_components=20, bin_fact=10, path=&quot;&quot;, basis_function=&quot;SHO&quot;,with_log_transform = true)</code></pre><p>Plot the posterior predictive Lomb-Scargle periodogram of random time series from the model to compare with the one of the data.</p><p><strong>Arguments</strong></p><ul><li><code>samples::Array{Float64, n}</code> : Posterior samples</li><li><code>t::Array{Float64, 1}</code> : Time series</li><li><code>y::Array{Float64, 1}</code> : The values of the time series</li><li><code>yerr::Array{Float64, 1}</code> : The errors of the time series</li><li><code>GP_model::Function</code> : The GP model is a function that returns a ScalableGP conditionned on t and yerr, its arguments are t,y,yerr,params</li><li><code>S_low = 20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high = 20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>plot_f_P::Bool=false</code> : If true, the plot is made in terms of f * PSD</li><li><code>n_frequencies::Int=1000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>n_samples::Int=1000</code> : The number of samples to draw from the posterior predictive distribution</li><li><code>is_integrated_power::Bool = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li><li><code>bin_fact::Int=10</code> : The binning factor for the LSP</li><li><code>path::String=&quot;&quot;</code> : The path to save the plots</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>with_log_transform = true</code> : Apply a log transform to the data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L480-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_mean_approx-Tuple{Any, Any, Any}" href="#Pioran.plot_mean_approx-Tuple{Any, Any, Any}"><code>Pioran.plot_mean_approx</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_mean_approx(f, residuals, ratios; path=&quot;&quot;)</code></pre><p>Plot the frequency-averaged residuals and ratios</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_ppc_timeseries-NTuple{7, Any}" href="#Pioran.plot_ppc_timeseries-NTuple{7, Any}"><code>Pioran.plot_ppc_timeseries</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_ppc_timeseries(samples, t, y, yerr, GP_model, with_log_transform; t_pred = nothing, n_samples = 100, path = &quot;&quot;)</code></pre><p>Plot the posterior predictive time series and the residuals</p><p><strong>Arguments</strong></p><ul><li><code>samples::Matrix{Float64}</code> : The samples of the model parameters</li><li><code>t::Vector{Float64}</code> : The time series</li><li><code>y::Vector{Float64}</code> : The values of the time series</li><li><code>yerr::Vector{Float64}</code> : The errors of the time series</li><li><code>GP_model::PowerSpectralDensity</code> : The model</li><li><code>with_log_transform::Bool</code> : If true, the flux was log-transformed for the inference</li><li><code>t_pred::Vector{Float64}=nothing</code> : The prediction times</li><li><code>n_samples::Int=100</code> : The number of samples to draw from the posterior predictive distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L774-L788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_psd_ppc-NTuple{7, Any}" href="#Pioran.plot_psd_ppc-NTuple{7, Any}"><code>Pioran.plot_psd_ppc</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_psd_ppc(samples_ùìü, samples_norm, samples_ŒΩ, t, y, yerr, model; S_low = 20.0, S_high = 20.0, plot_f_P = false, n_frequencies = 1000, path = &quot;&quot;, n_components = 20, basis_function = &quot;SHO&quot;, is_integrated_power = true, with_log_transform = false, save_samples = false)</code></pre><p>Plot the posterior predictive power spectral density and the noise levels</p><p><strong>Arguments</strong></p><ul><li><code>samples_ùìü::Array{Float64, n}</code> : The samples of the model parameters</li><li><code>samples_norm::Array{Float64, 1}</code> : The normalisation samples, either variance or integrated power between <code>f_min</code> or <code>f_max</code>.</li><li><code>samples_ŒΩ::Array{Float64, 1}</code> : The ŒΩ samples</li><li><code>t::Array{Float64, 1}</code> : The time series</li><li><code>y::Array{Float64, 1}</code> : The values of the time series</li><li><code>yerr::Array{Float64, 1}</code> : The errors of the time series</li><li><code>model::Function</code> : The model</li><li><code>S_low = 20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high = 20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>plot_f_P::Bool = false</code> : If true, the plot is made in terms of f * PSD</li><li><code>n_frequencies::Int = 1000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>path::String = &quot;&quot;</code> : The path to save the plots</li><li><code>n_components::Int = 20</code> : The number of components to use for the approximation of the PSD</li><li><code>basis_function::String = &quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>is_integrated_power::Bool = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>with_log_transform::Bool = false</code> : If true, the flux is log-transformed.</li><li><code>save_samples::Bool = false</code> : Save samples of the psd and approx</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L337-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_quantiles_approx-NTuple{5, Any}" href="#Pioran.plot_quantiles_approx-NTuple{5, Any}"><code>Pioran.plot_quantiles_approx</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_quantiles_approx(f, f_min, f_max, residuals, ratios; path=&quot;&quot;)</code></pre><p>Plot the quantiles of the residuals and ratios (with respect to the approximated PSD) of the PSD</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_residuals_diagnostics-Tuple{Any, Any, Any}" href="#Pioran.plot_residuals_diagnostics-Tuple{Any, Any, Any}"><code>Pioran.plot_residuals_diagnostics</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_residuals_diagnostics(t, mean_res, res_quantiles; confidence_intervals=[95, 99], path=&quot;&quot;)</code></pre><p>Plot the residuals and the autocorrelation function of the residuals</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{Float64}</code> : The time series</li><li><code>mean_res::Vector{Float64}</code> : The mean of the residuals</li><li><code>res_quantiles::Array{Float64, 2}</code> : The quantiles of the residuals</li><li><code>confidence_intervals::Array{Int, 1}</code> : The confidence intervals</li><li><code>path::String=&quot;&quot;</code> : The path to save the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L664-L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_simu_ppc_timeseries-NTuple{5, Any}" href="#Pioran.plot_simu_ppc_timeseries-NTuple{5, Any}"><code>Pioran.plot_simu_ppc_timeseries</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_simu_ppc_timeseries(t_pred, ts_quantiles, t, y, yerr; path=&quot;&quot;)</code></pre><p>Plot the posterior predictive simulated time series</p><p><strong>Arguments</strong></p><ul><li><code>t_pred::Vector{Float64}</code> : The prediction times</li><li><code>ts_quantiles::Array{Float64, 2}</code> : The quantiles of the posterior predictive time series</li><li><code>t::Vector{Float64}</code> : The time series</li><li><code>y::Vector{Float64}</code> : The values of the time series</li><li><code>yerr::Vector{Float64}</code> : The errors of the time series</li><li><code>path::String=&quot;&quot;</code> : The path to save the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/plots_diagnostics.jl#L733-L745">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.check_conjugate_pair-Tuple{Vector{Complex}}" href="#Pioran.check_conjugate_pair-Tuple{Vector{Complex}}"><code>Pioran.check_conjugate_pair</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_conjugate_pair(r::Vector{Complex})</code></pre><p>Check if the roots are complex conjugate pairs and negative real parts Returns true if the roots are complex conjugate pairs and false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/utils.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.check_order_imag_roots-Tuple{Any}" href="#Pioran.check_order_imag_roots-Tuple{Any}"><code>Pioran.check_order_imag_roots</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_order_imag_roots(r::Vector{Complex})</code></pre><p>Check if the imaginary parts of the roots are in ascending order</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/utils.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.check_roots_bounds-Tuple{Vector{Complex}, Float64, Float64}" href="#Pioran.check_roots_bounds-Tuple{Vector{Complex}, Float64, Float64}"><code>Pioran.check_roots_bounds</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_roots_bounds(r::Vector{Complex},f_min::Float64,f_max::Float64)</code></pre><p>Check if the roots are within the bounds of the frequency range</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/utils.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.extract_subset-Tuple{Random.AbstractRNG, Vararg{Any, 4}}" href="#Pioran.extract_subset-Tuple{Random.AbstractRNG, Vararg{Any, 4}}"><code>Pioran.extract_subset</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_subset(rng, prefix, t, y, yerr; n_perc=0.03, take_log=true, suffix=&quot;&quot;)
extract_subset(seed, prefix, t, y, yerr; n_perc=0.03, take_log=true)</code></pre><p>Extract a subset of the data for the analysis and return initial guesses for the mean and variance. Either a random number generator or a seed can be provided.</p><p><strong>Arguments</strong></p><ul><li><code>seed::Int64</code> : Seed for the random number generator.</li><li><code>rng::AbstractRNG</code> : Random number generator.</li><li><code>prefix::String</code> : Prefix for the output files.</li><li><code>t::Array{Float64,1}</code> : Time array.</li><li><code>y::Array{Float64,1}</code> : Time series array.</li><li><code>yerr::Array{Float64,1}</code> : Time series error array.</li><li><code>n_perc::Float64</code> : Percentage of the time series to extract.</li><li><code>take_log::Bool</code> : If true, log transform the time series for the estimation of the mean and variance.</li><li><code>suffix::String</code> : Suffix for the output files.</li></ul><p><strong>Return</strong></p><ul><li><code>t_subset::Array{Float64,1}</code> : Time array of the subset.</li><li><code>y_subset::Array{Float64,1}</code> : Time series array of the subset.</li><li><code>yerr_subset::Array{Float64,1}</code> : Time series error array of the subset.</li><li><code>xÃÑ::Float64</code> : Mean of the normal distribution for Œº.</li><li><code>va::Float64</code> : Variance of the normal distribution for Œº.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/utils.jl#L2-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.makelist_namessplit-Tuple{Any}" href="#Pioran.makelist_namessplit-Tuple{Any}"><code>Pioran.makelist_namessplit</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>simply put entries of paramnames_split into lists even when it&#39;s a string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/utils.jl#L86-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.separate_samples-Tuple{Any, Any, Any}" href="#Pioran.separate_samples-Tuple{Any, Any, Any}"><code>Pioran.separate_samples</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">separate_samples(samples, paramnames, with_log_transform::Bool)</code></pre><p>Separate the samples into the parameters of the model and the parameters of the power spectral density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/utils.jl#L102-L107">source</a></section></article><h3 id="Prior-distributions"><a class="docs-heading-anchor" href="#Prior-distributions">Prior distributions</a><a id="Prior-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Prior-distributions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.ThreeUniformDependent" href="#Pioran.ThreeUniformDependent"><code>Pioran.ThreeUniformDependent</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThreeUniformDependent(a, b, c, œµ)
ThreeUniformDependent(a, b, c) (constructor with default œµ = 1e-10)</code></pre><p>Multivariate distribution to model three random variables  where the first one x1 is given by U[a,b] and the second one x2 is given by U[x1,c] and the third one x3 is given by U[x2,c]. where a&lt;b&lt;c.</p><ul><li><code>a</code>: lower bound of the first distribution</li><li><code>b</code>: upper bound of the first distribution</li><li><code>c</code>: upper bound of the second and third distribution</li><li><code>œµ</code>: small value to make sure that the lower and upper bounds of each distribution are different</li></ul><p>This means that the lower bound of the second distribution is dependent on the value of the first distribution and so on... This is implemented to overcome the limitations of the current Turing&#39;s implementation for dependent priors with dynamic support. See the following issues for more details: <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/priors.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.TwoLogUniformDependent" href="#Pioran.TwoLogUniformDependent"><code>Pioran.TwoLogUniformDependent</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoLogUniformDependent(a, b, œµ)
TwoLogUniformDependent(a, b) (constructor with default œµ = 1e-10</code></pre><p>Multivariate distribution to model three random variables  where the first one x1 is given by log-U[a,b] and the second one x2 is given by log-U[x1,b].</p><ul><li><code>a</code>: lower bound of the first distribution</li><li><code>b</code>: upper bound of the first distribution</li><li><code>œµ</code>: small value to make sure that the lower and upper bounds of each distribution are different</li></ul><p>This means that the lower bound of the second distribution is dependent on the value of the first distribution. This is implemented to overcome the limitations of the current Turing&#39;s implementation for dependent priors with dynamic support. See the following issues for more details: <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/priors.jl#L80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.TwoUniformDependent" href="#Pioran.TwoUniformDependent"><code>Pioran.TwoUniformDependent</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoUniformDependent(a, b, c, œµ)
TwoUniformDependent(a, b, c) (constructor with default œµ = 1e-10)</code></pre><p>Multivariate distribution to model two random variables  where the first one is given by U[a,b] and the second one is given by U[x,c], where x is a random variable sampled from the first distribution.</p><ul><li><code>a</code>: lower bound of the first distribution</li><li><code>b</code>: upper bound of the first distribution</li><li><code>c</code>: upper bound of the second distribution</li><li><code>œµ</code>: small value to make sure that the lower and upper bounds of each distribution are different</li></ul><p>This means that the lower bound of the second distribution is dependent on the value of the first distribution.This is implemented to overcome the limitations of the current Turing&#39;s implementation for dependent priors with dynamic support. See the following issues for more details: <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p><p><strong>Example</strong></p><p>#```jldoctest julia&gt; using Pioran, Distributions julia&gt; d = TwoUniformDependent(0, 1, 2) TwoUniformDependent(0.0, 1.0, 2.0)</p><p>julia&gt; rand(d) 2-element Array{Float64,1}:  0.123  1.234 #```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/priors.jl#L2-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bijectors.bijector-Tuple{TwoUniformDependent}" href="#Bijectors.bijector-Tuple{TwoUniformDependent}"><code>Bijectors.bijector</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bijectors.bijector(d::TwoUniformDependent)</code></pre><p>Create a bijector for the TwoUniformDependent distribution. This is used to sample from the distribution using the Bijectors package. Adapted from the following issues <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/priors.jl#L142-L147">source</a></section></article><h2 id="CARMA"><a class="docs-heading-anchor" href="#CARMA">CARMA</a><a id="CARMA-1"></a><a class="docs-heading-anchor-permalink" href="#CARMA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.CARMA" href="#Pioran.CARMA"><code>Pioran.CARMA</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CARMA(p, q, rŒ±, Œ≤, œÉ¬≤)</code></pre><p>Continuous-time AutoRegressive Moving Average (CARMA) model for the power spectral density</p><ul><li><code>p</code>: the order of the autoregressive polynomial</li><li><code>q</code>: the order of the moving average polynomial</li><li><code>rŒ±</code>: roots of the autoregressive polynomial length p+1</li><li><code>Œ≤</code>: the moving average coefficients length q+1</li><li><code>œÉ¬≤</code>: the variance of the process</li></ul><p>The power spectral density of the CARMA model is given by:</p><p class="math-container">\[\mathcal{P}(f) = \sigma^2 \left|\dfrac{\sum\limits_{k=0}^q \beta_k \left(2\pi\mathrm{i}f\right)^k }{\sum\limits_{l=0}^p \alpha_l \left(2\pi\mathrm{i}f\right)^l}\right|^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/CARMA.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.evaluate-Tuple{CARMA, Any}" href="#Pioran.evaluate-Tuple{CARMA, Any}"><code>Pioran.evaluate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(model::CARMA, f)</code></pre><p>evaluate the power spectral density of the CARMA model at frequency f.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/CARMA.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.quad2roots-Tuple{Any}" href="#Pioran.quad2roots-Tuple{Any}"><code>Pioran.quad2roots</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quad2roots(quad)</code></pre><p>Convert the coefficients of a quadratic polynomial to its roots.</p><p><strong>Arguments</strong></p><ul><li><code>quad::Vector{Real}</code>: Coefficients of the quadratic polynomial.</li></ul><p><strong>Returns</strong></p><ul><li><code>r::Vector{Complex}</code>: Roots of the polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/CARMA.jl#L181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.roots2coeffs-Tuple{Any}" href="#Pioran.roots2coeffs-Tuple{Any}"><code>Pioran.roots2coeffs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">roots2coeffs(r)</code></pre><p>Convert the roots of a polynomial to its coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>r::Vector{Complex}</code>: Roots of the polynomial.</li></ul><p><strong>Returns</strong></p><ul><li><code>c::Vector{Complex}</code>: Coefficients of the polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/bf4c7bed2f2abff2ad152e40bdd13d6f52f0385d/src/CARMA.jl#L165-L175">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bibliography/">¬´ Bibliography</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 8 September 2025 11:34">Monday 8 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
