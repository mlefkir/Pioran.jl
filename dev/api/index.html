<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Pioran.jl</title><meta name="title" content="API Reference · Pioran.jl"/><meta property="og:title" content="API Reference · Pioran.jl"/><meta property="twitter:title" content="API Reference · Pioran.jl"/><meta name="description" content="Pioran.jl: A Julia package for power spectral density estimation using scalable Gaussian processes."/><meta property="og:description" content="Pioran.jl: A Julia package for power spectral density estimation using scalable Gaussian processes."/><meta property="twitter:description" content="Pioran.jl: A Julia package for power spectral density estimation using scalable Gaussian processes."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Pioran.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pioran.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">Basic usage</span><ul><li><a class="tocitem" href="../explanation/">Spectral analysis in Pioran</a></li><li><a class="tocitem" href="../modelling/">Modelling</a></li><li><a class="tocitem" href="../simulations/">Simulations</a></li><li><a class="tocitem" href="../timeseries/">Time series and priors</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics post-inference</a></li><li><a class="tocitem" href="../basis_functions/">About the basis functions</a></li></ul></li><li><span class="tocitem">Inference</span><ul><li><a class="tocitem" href="../turing/">Hamiltonian Monte Carlo with Turing.jl</a></li><li><a class="tocitem" href="../ultranest/">Nested sampling with ultranest</a></li></ul></li><li><a class="tocitem" href="../carma/">CARMA</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Power-spectral-densities"><span>Power spectral densities</span></a></li><li><a class="tocitem" href="#Covariance-functions"><span>Covariance functions</span></a></li><li><a class="tocitem" href="#Gaussian-processes"><span>Gaussian processes</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#CARMA"><span>CARMA</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mlefkir/Pioran.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mlefkir/Pioran.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Power-spectral-densities"><a class="docs-heading-anchor" href="#Power-spectral-densities">Power spectral densities</a><a id="Power-spectral-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Power-spectral-densities" title="Permalink"></a></h2><h3 id="Models-and-functions"><a class="docs-heading-anchor" href="#Models-and-functions">Models and functions</a><a id="Models-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Models-and-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.DoubleBendingPowerLaw" href="#Pioran.DoubleBendingPowerLaw"><code>Pioran.DoubleBendingPowerLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> DoubleBendingPowerLaw(α₁, f₁, α₂, f₂, α₃)</code></pre><p>Double bending power law model for the power spectral density</p><ul><li><code>α₁</code>: the first power law index</li><li><code>f₁</code>: the first bend frequency</li><li><code>α₂</code>: the second power law index</li><li><code>f₂</code>: the second bend frequency</li><li><code>α₃</code>: the third power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  \frac{(f/f₁)^{-α₁}}{1 + (f / f₁)^{α₂ - α₁}}\frac{1}{1 + (f / f₂)^{α₃ - α₂}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.PowerLaw" href="#Pioran.PowerLaw"><code>Pioran.PowerLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> PowerLaw(α)</code></pre><p>Power law model for the power spectral density</p><ul><li><code>α</code>: the power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  f^{-α}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.SingleBendingPowerLaw" href="#Pioran.SingleBendingPowerLaw"><code>Pioran.SingleBendingPowerLaw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SingleBendingPowerLaw(α₁, f₁, α₂)</code></pre><p>Single bending power law model for the power spectral density</p><ul><li><code>α₁</code>: the first power law index</li><li><code>f₁</code>: the first bend frequency</li><li><code>α₂</code>: the second power law index</li></ul><p class="math-container">\[\mathcal{P}(f) =  \frac{(f/f₁)^{-α₁}}{1 + (f / f₁)^{α₂ - α₁}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L27-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.approx" href="#Pioran.approx"><code>Pioran.approx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approx(psd_model, f_min, f_max, n_components=20, norm=1.0,S_low::Real=20., S_high::Real=20. ; is_integrated_power::Bool = true, basis_function=&quot;SHO&quot;)</code></pre><p>Approximate the PSD with a sum of basis functions to form a covariance function. The PSD model is approximated between <code>f0=f_min/S_low</code> and <code>fM=f_min*S_high</code>. By default it is normalised by its integral from <code>f_min</code> to <code>f_max</code> but it can also be normalised by its integral from 0 to infinity using the <code>variance</code> argument.</p><p><strong>Arguments</strong></p><ul><li><code>psd_model::PowerSpectralDensity</code>: model of the PSD</li><li><code>f_min::Real</code>: the minimum frequency in the time series</li><li><code>f_max::Real</code>: the maximum frequency in the time series</li><li><code>n_components::Integer=20</code>: the number of basis functions to use</li><li><code>norm::Real=1.0</code>: normalisation of the PSD.</li><li><code>S_low::Real=20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high::Real=20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>is_integrated_power::Bool = true</code>: if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code>, if not it is the variance of the process, integral of the PSD from 0 to +inf.</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li></ul><p><strong>Return</strong></p><ul><li><code>covariance::SumOfSemiSeparable</code>: the covariance function</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Pioran
𝓟 = SingleBendingPowerLaw(1.0, 1.0, 2.0)
𝓡 = approx(𝓟, 1e-4, 1e-1, 30, 2.31,basis_function=&quot;SHO&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L239-L265">source</a></section></article><h3 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.approximated_psd-Tuple{Any, Pioran.PowerSpectralDensity, Real, Real}" href="#Pioran.approximated_psd-Tuple{Any, Pioran.PowerSpectralDensity, Real, Real}"><code>Pioran.approximated_psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> approximated_psd(f, psd_model, f0, fM; n_components=20, norm=1.0, basis_function=&quot;SHO&quot;)</code></pre><p>Return the approximated PSD. This is essentially to check that the model and the approximation are consistent.</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractVector{&lt;:Real}</code>: the frequencies at which to calculate the PSD</li><li><code>psd_model::PowerSpectralDensity</code>: model of the PSD</li><li><code>f0::Real</code>: the lowest frequency</li><li><code>fM::Real</code>: the highest frequency</li><li><code>n_components::Integer=20</code>: the number of basis functions to use</li><li><code>norm::Real=1.0</code>: normalisation of the PSD</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li><li><code>individual::Bool=false</code>: return the individual components</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L189-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.build_approx-Tuple{Int64, Real, Real}" href="#Pioran.build_approx-Tuple{Int64, Real, Real}"><code>Pioran.build_approx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> build_approx(J, f0, fM; basis_function=&quot;SHO&quot;)</code></pre><p>Prepare the approximation of a PSD</p><p><strong>Arguments</strong></p><ul><li><code>J::Integer</code>: the number of basis functions</li><li><code>f0::Real</code>: the lowest frequency</li><li><code>fM::Real</code>: the highest frequency</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li></ul><p><strong>Return</strong></p><ul><li><code>spectral_points::Vector{Real}</code>: the spectral points</li><li><code>spectral_matrix::Matrix{Real}</code>: the spectral matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L110-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.calculate-Tuple{Any, DoubleBendingPowerLaw}" href="#Pioran.calculate-Tuple{Any, DoubleBendingPowerLaw}"><code>Pioran.calculate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>calculate(f, psd::PowerSpectralDensity)</p><pre><code class="nohighlight hljs">Calculate the power spectral density at frequency f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_approx_coefficients-Tuple{Pioran.PowerSpectralDensity, Real, Real}" href="#Pioran.get_approx_coefficients-Tuple{Pioran.PowerSpectralDensity, Real, Real}"><code>Pioran.get_approx_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_approx_coefficients(psd_model, f0, fM; n_components=20, basis_function=&quot;SHO&quot;)</code></pre><p>Get the coefficients of the approximated PSD</p><p><strong>Arguments</strong></p><ul><li><code>psd_model::PowerSpectralDensity</code>: model of the PSD</li><li><code>f0::Real</code>: the lowest frequency</li><li><code>fM::Real</code>: the highest frequency</li><li><code>n_components::Integer=20</code>: the number of basis functions to use</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li></ul><p><strong>Return</strong></p><ul><li><code>amplitudes::Vector{Real}</code>: the amplitudes of the basis functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L166-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_norm_psd-NTuple{6, Any}" href="#Pioran.get_norm_psd-NTuple{6, Any}"><code>Pioran.get_norm_psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_norm_psd(amplitudes,spectral_points,f_min,f_max,basis_function,is_integrated_power)</code></pre><p>Get the normalisation of the sum of basis functions.</p><p><strong>Arguments</strong></p><ul><li><code>amplitudes</code>: amplitude of the basis function</li><li><code>spectral_points</code>: spectral points of the basis function</li><li><code>f_min::Real</code>: the minimum frequency in the time series</li><li><code>f_max::Real</code>: the maximum frequency in the time series</li><li><code>basis_function::String=&quot;SHO&quot;</code>: the basis function to use, either &quot;SHO&quot; or &quot;DRWCelerite&quot;</li><li><code>is_integrated_power::Bool=true</code>: if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L359-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_normalised_psd-Tuple{Pioran.PowerSpectralDensity, AbstractVector{&lt;:Real}}" href="#Pioran.get_normalised_psd-Tuple{Pioran.PowerSpectralDensity, AbstractVector{&lt;:Real}}"><code>Pioran.get_normalised_psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> get_normalised_psd(psd_model::PowerSpectralDensity, spectral_points::AbstractVector{&lt;:Real})</code></pre><p>Get the PSD normalised at the lowest frequency</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integral_drwcelerite-Tuple{Any, Any, Any}" href="#Pioran.integral_drwcelerite-Tuple{Any, Any, Any}"><code>Pioran.integral_drwcelerite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integral_drwcelerite(a, c, x)</code></pre><p>Computes the integral of the DRWCelerite basis function of amplitude <code>a</code> and width <code>c</code> for a given <code>x</code>.</p><p>The DRWCelerite basis function is defined as:</p><p class="math-container">\[    \int \dfrac{a\, {d}x}{(x/c)^6+1} =\dfrac{ac}{3} \left[ \arctan{(x/c)} +\dfrac{\sqrt3}{4}\ln{\left(\dfrac{x^2+xc\sqrt3+c^2}{x^2-xc\sqrt3+c^2}\right)}+\dfrac{1}{2}\arctan{\left(\dfrac{x^2-c^2}{xc}\right)}\right]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L325-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integral_sho-Tuple{Any, Any, Any}" href="#Pioran.integral_sho-Tuple{Any, Any, Any}"><code>Pioran.integral_sho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integral_sho(a, c, x)</code></pre><p>Computes the integral of the SHO basis function of amplitude a and width c for a given x.</p><p>This integral is obtained using Equation: 4.2.7.1.3 from the &quot;Handbook of Mathematical Formulas and Integrals&quot; 2009</p><p class="math-container">\[    \int \dfrac{a\, {d}x}{(x/c)^4+1} =\dfrac{ac}{4\sqrt2} \left[\ln{\left(\dfrac{x^2+cx\sqrt2+c^2}{x^2-cx\sqrt2+c^2}\right)}+2\arctan{\left(\dfrac{cx\sqrt2}{c^2-x^2}\right)}\right]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L309-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.integrate_basis_function-NTuple{5, Any}" href="#Pioran.integrate_basis_function-NTuple{5, Any}"><code>Pioran.integrate_basis_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_basis_function(a,c,x₁,x₂,basis_function)</code></pre><p>Computes the integral of the basis function between x₁ and x₂ for a given amplitude a and width c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.psd_decomp-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#Pioran.psd_decomp-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>Pioran.psd_decomp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> psd_decomp(psd_normalised, spectral_matrix)</code></pre><p>Get amplitudes of the basis functions by solving the linear system of the approximation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/psd.jl#L156-L160">source</a></section></article><h2 id="Covariance-functions"><a class="docs-heading-anchor" href="#Covariance-functions">Covariance functions</a><a id="Covariance-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-functions" title="Permalink"></a></h2><h3 id="Models-and-functions-2"><a class="docs-heading-anchor" href="#Models-and-functions-2">Models and functions</a><a class="docs-heading-anchor-permalink" href="#Models-and-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.Exp" href="#Pioran.Exp"><code>Pioran.Exp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Exp(A, α)</code></pre><p>Exponential covariance Function</p><ul><li><code>A</code>: the amplitude of the covariance function</li><li><code>α</code>: the decay rate of the covariance function</li></ul><p class="math-container">\[k(τ) = A \exp(-α τ)\]</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Exp(1.0, 0.25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/Exp.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.SHO" href="#Pioran.SHO"><code>Pioran.SHO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> SHO(A, ω₀, Q)</code></pre><p>Simple Harmonic Oscillator covariance Function</p><ul><li><code>A</code>: the amplitude of the covariance function</li><li><code>ω₀</code>: the angular frequency of the simple harmonic oscillator</li><li><code>Q</code>: the quality factor of the simple harmonic oscillator</li></ul><p class="math-container">\[k(τ) = A \exp(-ω₀ τ / Q / 2) \left\{\begin{matrix} 2(1 + ω₀ τ) &amp; Q = 1/2 \\ \cos(η ω₀ τ) + \frac{\sin(η ω₀ τ)}{2η Q} &amp; Q &lt; 1/2 \\ \cosh(η ω₀ τ) + \frac{\sinh(η ω₀ τ)}{2η Q} &amp; Q \geq 1/2 \end{matrix}\right.\\
η = \sqrt{\left|1 - \frac{1}{4 Q^2}\right|}\]</p><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/SHO.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.Celerite" href="#Pioran.Celerite"><code>Pioran.Celerite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Celerite(a, b, c, d)</code></pre><p>Celerite covariance Function</p><ul><li><code>a</code>: the amplitude of the first term</li><li><code>b</code>: the amplitude of the second term</li><li><code>c</code>: the decay rate of the covariance function</li><li><code>d</code>: the <code>period</code> of the covariance function</li></ul><p class="math-container">\[k(τ) = \exp(-c τ) (a \cos(d τ) + b \sin(d τ))\]</p><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/Celerite.jl#L3-L19">source</a></section></article><h3 id="Helper-functions-2"><a class="docs-heading-anchor" href="#Helper-functions-2">Helper functions</a><a class="docs-heading-anchor-permalink" href="#Helper-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Pioran.SemiSeparable, Pioran.SemiSeparable}" href="#Base.:+-Tuple{Pioran.SemiSeparable, Pioran.SemiSeparable}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> +(::SemiSeparable, ::SemiSeparable)

Sum of semi-separable covariance functions</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/acvf.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.celerite_coefs-Tuple{Pioran.SumOfSemiSeparable}" href="#Pioran.celerite_coefs-Tuple{Pioran.SumOfSemiSeparable}"><code>Pioran.celerite_coefs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> celerite_coefs(covariance)

Get the celerite coefficients</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/acvf.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.calculate-Tuple{Any, Exp}" href="#Pioran.calculate-Tuple{Any, Exp}"><code>Pioran.calculate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>calculate(f, C::Exp)</p><pre><code class="nohighlight hljs">This is the right formula but it disagrees with the Celerite implementation...

Calculate the power spectral density at frequency f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/Exp.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.calculate-Tuple{Any, Celerite}" href="#Pioran.calculate-Tuple{Any, Celerite}"><code>Pioran.calculate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>calculate(f, C::Celerite)</p><pre><code class="nohighlight hljs">Calculate the power spectral density at frequency f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/Celerite.jl#L54-L58">source</a></section></article><h2 id="Gaussian-processes"><a class="docs-heading-anchor" href="#Gaussian-processes">Gaussian processes</a><a id="Gaussian-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.ScalableGP" href="#Pioran.ScalableGP"><code>Pioran.ScalableGP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A scalable Gaussian process has a covariance function formed of semi-separable kernels</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Pioran
𝓟 = SingleBendingPowerLaw(1.0, 1.0, 2.0)
𝓡 = approx(𝓟, 1e-4, 1e-1, 30, 2.31,basis_function=&quot;SHO&quot;)
μ = 1.2

f = ScalableGP(𝓡) # zero-mean GP
f = ScalableGP(μ, 𝓡) # with mean μ</code></pre><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(rng::AbstractRNG, fp::PosteriorGP, N::Int=1)
rand(rng::AbstractRNG, fp::PosteriorGP, τ::AbstractVecOrMat{&lt;:Real}, N::Int=1)
rand(fp::PosteriorGP, N::Int=1)</code></pre><p>Sample <code>N</code> realisations from the posterior GP <code>fp</code> at the points <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, AbstractGPs.FiniteGP{&lt;:ScalableGP}}" href="#Base.rand-Tuple{Random.AbstractRNG, AbstractGPs.FiniteGP{&lt;:ScalableGP}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(rng::AbstractRNG, f::ScalableGP)
rand(rng::AbstractRNG, f::ScalableGP, t::AbstractVecOrMat{&lt;:Real})
rand(f::ScalableGP)
rand(f::ScalableGP, t::AbstractVecOrMat{&lt;:Real})</code></pre><p>Draw a realisation from the GP <code>f</code> at the points <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}" href="#Distributions.logpdf-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logpdf(f::ScalableGP, Y::AbstractVecOrMat{&lt;:Real})</code></pre><p>Compute the log-likelihood of the data Y given the GP f.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran._predict_cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Pioran._predict_cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Pioran._predict_cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_predict_cov(fp::PosteriorGP, τ::AbstractVecOrMat{&lt;:Real})
Compute the posterior covariance of the GP at the points τ.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L56-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran._predict_mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Pioran._predict_mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Pioran._predict_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_predict_mean(fp::PosteriorGP, τ::AbstractVecOrMat{&lt;:Real})

Compute the Posterior mean of the GP at the points τ.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.posterior-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}" href="#Pioran.posterior-Tuple{AbstractGPs.FiniteGP{&lt;:ScalableGP}, AbstractVecOrMat{&lt;:Real}}"><code>Pioran.posterior</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">posterior(f::ScalableGP, y::AbstractVecOrMat{&lt;:Real})</code></pre><p>Compute the posterior Gaussian process <code>fp</code> given the GP <code>f</code> and the data <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Statistics.cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Statistics.cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cov(fp::PosteriorGP, τ::AbstractVecOrMat{&lt;:Real})
cov(fp::PosteriorGP)</code></pre><p>Compute the covariance of the posterior GP at the points τ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}" href="#Statistics.mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{&lt;:Real}}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean(fp::PosteriorGP, τ::AbstractVecOrMat{&lt;:Real})
mean(fp::PosteriorGP)</code></pre><p>Compute the mean of the posterior GP at the points τ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Tuple{Pioran.PosteriorGP}" href="#Statistics.std-Tuple{Pioran.PosteriorGP}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">std(fp::PosteriorGP, τ::AbstractVecOrMat{&lt;:Real})
std(fp::PosteriorGP)</code></pre><p>Compute the standard deviation of the posterior GP at the points τ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/scalable_GP.jl#L84-L89">source</a></section></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><h3 id="Celerite-solver"><a class="docs-heading-anchor" href="#Celerite-solver">Celerite solver</a><a id="Celerite-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Celerite-solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.compute_nll-NTuple{7, Any}" href="#Pioran.compute_nll-NTuple{7, Any}"><code>Pioran.compute_nll</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_nll(t, y, σ², a, b, c, d)

Compute the likelihood using the vectorised implementation in `get_values!`.

Still experimental.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L221-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_values!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}" href="#Pioran.get_values!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractVector}"><code>Pioran.get_values!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_values!(a, b, c, d, zp, U, V, P, D, t)</code></pre><p>Compute the values of the matrices and vectors needed for the celerite algorithm. This is a vectorised version of the <code>init_semi_separable!</code> and <code>solve_prec!</code> functions. This function appears to be faster than the two previous functions when J &gt; 16 but it also uses more memory.</p><p>More study of this implementation is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.log_likelihood-Tuple{Pioran.SumOfCelerite, Any, Any, Any}" href="#Pioran.log_likelihood-Tuple{Pioran.SumOfCelerite, Any, Any, Any}"><code>Pioran.log_likelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log_likelihood(cov, τ, y, σ2)</code></pre><p>Compute the log-likelihood of a semi-separable covariance function using the celerite algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>cov::SumOfSemiSeparable</code> or <code>cov::CARMA</code> or <code>cov::SemiSeparable</code>: the covariance function</li><li><code>τ::Vector</code>: the time points</li><li><code>y::Vector</code>: the data</li><li><code>σ2::Vector</code>: the measurement variances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L253-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.logl-NTuple{7, Any}" href="#Pioran.logl-NTuple{7, Any}"><code>Pioran.logl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logl(a, b, c, d, τ, y, σ2)</code></pre><p>Compute the log-likelihood of a GP with a semi-separable covariance function using the celerite algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>a::Vector</code></li><li><code>b::Vector</code></li><li><code>c::Vector</code></li><li><code>d::Vector</code></li><li><code>τ::Vector</code>: the time points</li><li><code>y::Vector</code>: the data</li><li><code>σ2::Vector</code>: the measurement variances</li></ul><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L280-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.predict-Tuple{Pioran.SumOfSemiSeparable, Vararg{AbstractVector, 4}}" href="#Pioran.predict-Tuple{Pioran.SumOfSemiSeparable, Vararg{AbstractVector, 4}}"><code>Pioran.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(cov, τ, t, y, σ2)</code></pre><p>Compute the posterior mean of the GP at the points τ given the data y and time t.</p><p><strong>Arguments</strong></p><ul><li><code>cov::SumOfSemiSeparable</code> or <code>cov::CARMA</code> or <code>cov::SemiSeparable</code>: the covariance function</li><li><code>τ::Vector</code>: the time points</li><li><code>t::Vector</code>: the data time points</li><li><code>y::Vector</code>: the data</li><li><code>σ2::Vector</code>: the measurement variances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L320-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.simulate-Tuple{Random.AbstractRNG, Pioran.SumOfSemiSeparable, AbstractVector, AbstractVector}" href="#Pioran.simulate-Tuple{Random.AbstractRNG, Pioran.SumOfSemiSeparable, AbstractVector, AbstractVector}"><code>Pioran.simulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(rng, cov, τ, σ2)
simulate(cov, τ, σ2)</code></pre><p>Draw a realisation from the  GP with the covariance function cov at the points τ with the variances σ2.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: the random number generator</li><li><code>cov::SumOfSemiSeparable</code> or <code>cov::CARMA</code> or <code>cov::SemiSeparable</code>: the covariance function</li><li><code>τ::Vector</code>: the time points</li><li><code>σ2::Vector</code>: the measurement variances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L469-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.solve_prec!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}" href="#Pioran.solve_prec!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}"><code>Pioran.solve_prec!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_prec!(z, y, U, W, D, ϕ)</code></pre><p>Forward and backward substitution of the celerite algorithm.</p><p>See <a href="https://ui.adsabs.harvard.edu/abs/2017AJ....154..220F">Foreman-Mackey et al. (2017)</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/celerite_solver.jl#L110-L116">source</a></section></article><h3 id="Direct-solver"><a class="docs-heading-anchor" href="#Direct-solver">Direct solver</a><a id="Direct-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.log_likelihood_direct-Tuple{KernelFunctions.SimpleKernel, Vector, Vector, Vector}" href="#Pioran.log_likelihood_direct-Tuple{KernelFunctions.SimpleKernel, Vector, Vector, Vector}"><code>Pioran.log_likelihood_direct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log_likelihood_direct(cov::KernelFunctions.SimpleKernel, t::Vector, y::Vector, σ²::Vector)

Compute the log-likelihood of the data Y given the GP f with the direct solver.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/direct_solver.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.predict_cov-Tuple{KernelFunctions.SimpleKernel, AbstractVector, AbstractVector, AbstractVector}" href="#Pioran.predict_cov-Tuple{KernelFunctions.SimpleKernel, AbstractVector, AbstractVector, AbstractVector}"><code>Pioran.predict_cov</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_direct(cov::KernelFunctions.SimpleKernel, τ::AbstractVector, t::AbstractVector, σ²::AbstractVector)

Compute the posterior covariance of the GP at the points τ given the times t and the noise variance σ².</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/direct_solver.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.predict_direct" href="#Pioran.predict_direct"><code>Pioran.predict_direct</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_direct(cov::KernelFunctions.SimpleKernel, τ::AbstractVector, t::AbstractVector, y::AbstractVector, σ²::AbstractVector, with_covariance::Bool=false)

Compute the posterior mean of the GP at the points τ given the data (t, y) and the noise variance σ².</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/direct_solver.jl#L70-L74">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><h3 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.run_diagnostics" href="#Pioran.run_diagnostics"><code>Pioran.run_diagnostics</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_diagnostics(prior_samples, norm_samples, f_min, f_max, model, S_low=20.0, S_high=20.0; path=&quot;&quot;, basis_function=&quot;SHO&quot;, n_components=20)</code></pre><p>Run the prior predictive checks for the model and the approximation of the PSD</p><p><strong>Arguments</strong></p><ul><li><code>prior_samples::Array{Float64, 2}</code> : Model samples from the prior distribution</li><li><code>norm_samples::Array{Float64, 1}</code> : The samples of the normalisation of the PSD</li><li><code>f_min::Float64</code> : The minimum frequency of the observed data</li><li><code>f_max::Float64</code> : The maximum frequency of the observed data</li><li><code>model::Function</code> : The model</li><li><code>S_low::Float64=20.0</code> : the scaling factor for the appoximation at low frequencies</li><li><code>S_high::Float64=20.0</code> : the scaling factor for the appoximation at high frequencies</li><li><code>path::String=&quot;&quot;</code> : The path to save the plots</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L216-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.run_posterior_predict_checks-NTuple{7, Any}" href="#Pioran.run_posterior_predict_checks-NTuple{7, Any}"><code>Pioran.run_posterior_predict_checks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_posterior_predict_checks(samples, paramnames, t, y, yerr, model, with_log_transform; S_low = 20, S_high = 20, is_integrated_power = true, plots = &quot;all&quot;, n_samples = 100, path = &quot;&quot;, basis_function = &quot;SHO&quot;, n_frequencies = 1000, plot_f_P = false, n_components = 20)</code></pre><p>Run the posterior predictive checks for the model and the approximation of the PSD</p><p><strong>Arguments</strong></p><ul><li><code>samples::Array{Float64, 2}</code> : The samples from the posterior distribution</li><li><code>paramnames::Array{String, 1}</code> : The names of the parameters</li><li><code>t::Array{Float64, 1}</code> : The time series</li><li><code>y::Array{Float64, 1}</code> : The values of the time series</li><li><code>yerr::Array{Float64, 1}</code> : The errors of the time series</li><li><code>model::Function</code> : The model</li><li><code>with_log_transform::Bool</code> : If true, the flux is log-transformed</li><li><code>S_low::Float64=20.0</code> : the scaling factor for the appoximation at low frequencies</li><li><code>S_high::Float64=20.0</code> : the scaling factor for the appoximation at high frequencies</li><li><code>plots::String or Array{String, 1}</code> : The type of plots to make. It can be &quot;all&quot;, &quot;psd&quot;, &quot;lsp&quot;, &quot;timeseries&quot; or a combination of them in an array</li><li><code>n_samples::Int=200</code> : The number of samples to draw from the posterior predictive distribution</li><li><code>path::String=&quot;all&quot;</code> : The path to save the plots</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>is_integrated_power = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>n_frequencies::Int=1000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>plot_f_P::Bool=false</code> : If true, the plots are made in terms of f * PSD</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L244-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.sample_approx_model-NTuple{5, Any}" href="#Pioran.sample_approx_model-NTuple{5, Any}"><code>Pioran.sample_approx_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_approx_model(samples, norm_samples, f0, fM, model; n_frequencies=1_000, basis_function=&quot;SHO&quot;, n_components=20)</code></pre><p>Check the approximation of the PSD by computing the residuals and the ratios of the PSD and the approximated PSD</p><p><strong>Arguments</strong></p><ul><li><code>samples::Array{Float64, n}</code> : The model samples</li><li><code>norm_samples::Array{Float64, 1}</code> : The normalisation samples</li><li><code>f0::Float64</code> : The minimum frequency for the approximation of the PSD</li><li><code>fM::Float64</code> : The maximum frequency for the approximation of the PSD</li><li><code>model::Function</code> : The model</li><li><code>n_frequencies::Int=1_000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li><li><code>is_integrated_power=true</code>: Does the normalisation correspond to the integral of the PSD between two frequencies? If false, it corresponds to the true variance of the process.</li></ul><p><strong>Return</strong></p><ul><li><code>psd::Array{Float64, 2}</code> : The PSD</li><li><code>psd_approx::Array{Float64, 2}</code> : The approximated PSD</li><li><code>residuals::Array{Float64, 2}</code> : The residuals (psd-approx_psd)</li><li><code>ratios::Array{Float64, 2}</code> : The ratios (approx_psd/psd)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L173-L195">source</a></section></article><h3 id="Individual-plotting-functions"><a class="docs-heading-anchor" href="#Individual-plotting-functions">Individual plotting functions</a><a id="Individual-plotting-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-plotting-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.get_ppc_timeseries-NTuple{9, Any}" href="#Pioran.get_ppc_timeseries-NTuple{9, Any}"><code>Pioran.get_ppc_timeseries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ppc_timeseries(samples_𝓟, samples_norm, samples_ν, samples_μ, t, y, yerr, model, with_log_transform; S_low=20, S_high =20, t_pred = nothing, samples_c = nothing, n_samples = 1000, n_components = 20, basis_function = &quot;SHO&quot;, is_integrated_power = true)</code></pre><p>Get the random posterior predictive time series from the model and samples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L620-L624">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_boxplot_psd_approx-Tuple{Any, Any}" href="#Pioran.plot_boxplot_psd_approx-Tuple{Any, Any}"><code>Pioran.plot_boxplot_psd_approx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_boxplot_psd_approx(residuals, ratios; path=&quot;&quot;)</code></pre><p>Plot the boxplot of the residuals and ratios for the PSD approximation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_lsp_ppc-NTuple{8, Any}" href="#Pioran.plot_lsp_ppc-NTuple{8, Any}"><code>Pioran.plot_lsp_ppc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_lsp_ppc(samples_𝓟, samples_norm, samples_ν, samples_μ, t, y, yerr, f0, fM, model; plot_f_P=false, n_frequencies=1000, n_samples=1000, is_integrated_power = true, n_components=20, bin_fact=10, path=&quot;&quot;, basis_function=&quot;SHO&quot;,with_log_transform = true)</code></pre><p>Plot the posterior predictive Lomb-Scargle periodogram of random time series from the model to compare with the one of the data.</p><p><strong>Arguments</strong></p><ul><li><code>samples_𝓟::Array{Float64, n}</code> : The samples of the model parameters</li><li><code>samples_norm::Array{Float64, 1}</code> : The variance samples</li><li><code>samples_ν::Array{Float64, 1}</code> : The ν samples</li><li><code>samples_μ::Array{Float64, 1}</code> : The μ samples</li><li><code>t::Array{Float64, 1}</code> : The time series</li><li><code>y::Array{Float64, 1}</code> : The values of the time series</li><li><code>yerr::Array{Float64, 1}</code> : The errors of the time series</li><li><code>model::Function</code> : The model</li><li><code>S_low = 20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high = 20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>plot_f_P::Bool=false</code> : If true, the plot is made in terms of f * PSD</li><li><code>n_frequencies::Int=1000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>n_samples::Int=1000</code> : The number of samples to draw from the posterior predictive distribution</li><li><code>is_integrated_power::Bool = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li><li><code>bin_fact::Int=10</code> : The binning factor for the LSP</li><li><code>path::String=&quot;&quot;</code> : The path to save the plots</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>with_log_transform = true</code> : Apply a log transform to the data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L479-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_mean_approx-Tuple{Any, Any, Any}" href="#Pioran.plot_mean_approx-Tuple{Any, Any, Any}"><code>Pioran.plot_mean_approx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_mean_approx(f, residuals, ratios; path=&quot;&quot;)</code></pre><p>Plot the frequency-averaged residuals and ratios</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_ppc_timeseries-NTuple{9, Any}" href="#Pioran.plot_ppc_timeseries-NTuple{9, Any}"><code>Pioran.plot_ppc_timeseries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_ppc_timeseries(samples_𝓟, samples_norm, samples_ν, samples_μ, t, y, yerr, f0, fM, model, with_log_transform;S_low = 20, S_high = 20, t_pred = nothing, samples_c = nothing, n_samples = 100, n_components = 20, basis_function = &quot;SHO&quot;, path = &quot;&quot;,is_integrated_power=true)</code></pre><p>Plot the posterior predictive time series and the residuals</p><p><strong>Arguments</strong></p><ul><li><code>samples_𝓟::Matrix{Float64}</code> : The samples of the model parameters</li><li><code>samples_norm::Vector{Float64}</code> : The variance samples</li><li><code>samples_ν::Vector{Float64}</code> : The noise level samples</li><li><code>samples_μ::Vector{Float64}</code> : The mean samples</li><li><code>t::Vector{Float64}</code> : The time series</li><li><code>y::Vector{Float64}</code> : The values of the time series</li><li><code>yerr::Vector{Float64}</code> : The errors of the time series</li><li><code>model::PowerSpectralDensity</code> : The model</li><li><code>with_log_transform::Bool</code> : If true, the flux was log-transformed for the inference</li><li><code>S_low = 20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high = 20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>t_pred::Vector{Float64}=nothing</code> : The prediction times</li><li><code>samples_c::Vector{Float64}=nothing</code> : The samples of the constant (if the flux was log-transformed)</li><li><code>n_samples::Int=100</code> : The number of samples to draw from the posterior predictive distribution</li><li><code>n_components::Int=20</code> : The number of components to use for the approximation of the PSD</li><li><code>basis_function::String=&quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>is_integrated_power::Bool = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L791-L815">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_psd_ppc-NTuple{7, Any}" href="#Pioran.plot_psd_ppc-NTuple{7, Any}"><code>Pioran.plot_psd_ppc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_psd_ppc(samples_𝓟, samples_norm, samples_ν, t, y, yerr, model; S_low = 20.0, S_high = 20.0, plot_f_P = false, n_frequencies = 1000, path = &quot;&quot;, n_components = 20, basis_function = &quot;SHO&quot;, is_integrated_power = true, with_log_transform = false, save_samples = false)</code></pre><p>Plot the posterior predictive power spectral density and the noise levels</p><p><strong>Arguments</strong></p><ul><li><code>samples_𝓟::Array{Float64, n}</code> : The samples of the model parameters</li><li><code>samples_norm::Array{Float64, 1}</code> : The normalisation samples, either variance or integrated power between <code>f_min</code> or <code>f_max</code>.</li><li><code>samples_ν::Array{Float64, 1}</code> : The ν samples</li><li><code>t::Array{Float64, 1}</code> : The time series</li><li><code>y::Array{Float64, 1}</code> : The values of the time series</li><li><code>yerr::Array{Float64, 1}</code> : The errors of the time series</li><li><code>model::Function</code> : The model</li><li><code>S_low = 20.0</code>: scaling factor for the lowest frequency in the approximation.</li><li><code>S_high = 20.0</code>: scaling factor for the highest frequency in the approximation.</li><li><code>plot_f_P::Bool = false</code> : If true, the plot is made in terms of f * PSD</li><li><code>n_frequencies::Int = 1000</code> : The number of frequencies to use for the approximation of the PSD</li><li><code>path::String = &quot;&quot;</code> : The path to save the plots</li><li><code>n_components::Int = 20</code> : The number of components to use for the approximation of the PSD</li><li><code>basis_function::String = &quot;SHO&quot;</code> : The basis function for the approximation of the PSD</li><li><code>is_integrated_power::Bool = true</code> : if the norm corresponds to integral of the PSD between <code>f_min</code> and <code>f_max</code> or if it is the integral from 0 to infinity.</li><li><code>with_log_transform::Bool = false</code> : If true, the flux is log-transformed.</li><li><code>save_samples::Bool = false</code> : Save samples of the psd and approx</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L337-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_quantiles_approx-NTuple{5, Any}" href="#Pioran.plot_quantiles_approx-NTuple{5, Any}"><code>Pioran.plot_quantiles_approx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_quantiles_approx(f, f_min, f_max, residuals, ratios; path=&quot;&quot;)</code></pre><p>Plot the quantiles of the residuals and ratios (with respect to the approximated PSD) of the PSD</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_residuals_diagnostics-Tuple{Any, Any, Any}" href="#Pioran.plot_residuals_diagnostics-Tuple{Any, Any, Any}"><code>Pioran.plot_residuals_diagnostics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_residuals_diagnostics(t, mean_res, res_quantiles; confidence_intervals=[95, 99], path=&quot;&quot;)</code></pre><p>Plot the residuals and the autocorrelation function of the residuals</p><p><strong>Arguments</strong></p><ul><li><code>t::Vector{Float64}</code> : The time series</li><li><code>mean_res::Vector{Float64}</code> : The mean of the residuals</li><li><code>res_quantiles::Array{Float64, 2}</code> : The quantiles of the residuals</li><li><code>confidence_intervals::Array{Int, 1}</code> : The confidence intervals</li><li><code>path::String=&quot;&quot;</code> : The path to save the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L681-L692">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.plot_simu_ppc_timeseries-NTuple{5, Any}" href="#Pioran.plot_simu_ppc_timeseries-NTuple{5, Any}"><code>Pioran.plot_simu_ppc_timeseries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_simu_ppc_timeseries(t_pred, ts_quantiles, t, y, yerr; path=&quot;&quot;)</code></pre><p>Plot the posterior predictive simulated time series</p><p><strong>Arguments</strong></p><ul><li><code>t_pred::Vector{Float64}</code> : The prediction times</li><li><code>ts_quantiles::Array{Float64, 2}</code> : The quantiles of the posterior predictive time series</li><li><code>t::Vector{Float64}</code> : The time series</li><li><code>y::Vector{Float64}</code> : The values of the time series</li><li><code>yerr::Vector{Float64}</code> : The errors of the time series</li><li><code>path::String=&quot;&quot;</code> : The path to save the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/plots_diagnostics.jl#L750-L762">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.check_conjugate_pair-Tuple{Vector{Complex}}" href="#Pioran.check_conjugate_pair-Tuple{Vector{Complex}}"><code>Pioran.check_conjugate_pair</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_conjugate_pair(r::Vector{Complex})</code></pre><p>Check if the roots are complex conjugate pairs and negative real parts Returns true if the roots are complex conjugate pairs and false otherwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/utils.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.check_order_imag_roots-Tuple{Any}" href="#Pioran.check_order_imag_roots-Tuple{Any}"><code>Pioran.check_order_imag_roots</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_order_imag_roots(r::Vector{Complex})</code></pre><p>Check if the imaginary parts of the roots are in ascending order</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/utils.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.check_roots_bounds-Tuple{Vector{Complex}, Float64, Float64}" href="#Pioran.check_roots_bounds-Tuple{Vector{Complex}, Float64, Float64}"><code>Pioran.check_roots_bounds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_roots_bounds(r::Vector{Complex},f_min::Float64,f_max::Float64)</code></pre><p>Check if the roots are within the bounds of the frequency range</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/utils.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.extract_subset-Tuple{Random.AbstractRNG, Vararg{Any, 4}}" href="#Pioran.extract_subset-Tuple{Random.AbstractRNG, Vararg{Any, 4}}"><code>Pioran.extract_subset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_subset(rng, prefix, t, y, yerr; n_perc=0.03, take_log=true, suffix=&quot;&quot;)
extract_subset(seed, prefix, t, y, yerr; n_perc=0.03, take_log=true)</code></pre><p>Extract a subset of the data for the analysis and return initial guesses for the mean and variance. Either a random number generator or a seed can be provided.</p><p><strong>Arguments</strong></p><ul><li><code>seed::Int64</code> : Seed for the random number generator.</li><li><code>rng::AbstractRNG</code> : Random number generator.</li><li><code>prefix::String</code> : Prefix for the output files.</li><li><code>t::Array{Float64,1}</code> : Time array.</li><li><code>y::Array{Float64,1}</code> : Time series array.</li><li><code>yerr::Array{Float64,1}</code> : Time series error array.</li><li><code>n_perc::Float64</code> : Percentage of the time series to extract.</li><li><code>take_log::Bool</code> : If true, log transform the time series for the estimation of the mean and variance.</li><li><code>suffix::String</code> : Suffix for the output files.</li></ul><p><strong>Return</strong></p><ul><li><code>t_subset::Array{Float64,1}</code> : Time array of the subset.</li><li><code>y_subset::Array{Float64,1}</code> : Time series array of the subset.</li><li><code>yerr_subset::Array{Float64,1}</code> : Time series error array of the subset.</li><li><code>x̄::Float64</code> : Mean of the normal distribution for μ.</li><li><code>va::Float64</code> : Variance of the normal distribution for μ.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/utils.jl#L2-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.separate_samples-Tuple{Any, Any, Bool}" href="#Pioran.separate_samples-Tuple{Any, Any, Bool}"><code>Pioran.separate_samples</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">separate_samples(samples, paramnames, with_log_transform::Bool)</code></pre><p>Separate the samples into the parameters of the model and the parameters of the power spectral density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/utils.jl#L86-L91">source</a></section></article><h3 id="Prior-distributions"><a class="docs-heading-anchor" href="#Prior-distributions">Prior distributions</a><a id="Prior-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Prior-distributions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.ThreeUniformDependent" href="#Pioran.ThreeUniformDependent"><code>Pioran.ThreeUniformDependent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThreeUniformDependent(a, b, c, ϵ)
ThreeUniformDependent(a, b, c) (constructor with default ϵ = 1e-10)</code></pre><p>Multivariate distribution to model three random variables  where the first one x1 is given by U[a,b] and the second one x2 is given by U[x1,c] and the third one x3 is given by U[x2,c]. where a&lt;b&lt;c.</p><ul><li><code>a</code>: lower bound of the first distribution</li><li><code>b</code>: upper bound of the first distribution</li><li><code>c</code>: upper bound of the second and third distribution</li><li><code>ϵ</code>: small value to make sure that the lower and upper bounds of each distribution are different</li></ul><p>This means that the lower bound of the second distribution is dependent on the value of the first distribution and so on... This is implemented to overcome the limitations of the current Turing&#39;s implementation for dependent priors with dynamic support. See the following issues for more details: <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/priors.jl#L49-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.TwoLogUniformDependent" href="#Pioran.TwoLogUniformDependent"><code>Pioran.TwoLogUniformDependent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoLogUniformDependent(a, b, ϵ)
TwoLogUniformDependent(a, b) (constructor with default ϵ = 1e-10</code></pre><p>Multivariate distribution to model three random variables  where the first one x1 is given by log-U[a,b] and the second one x2 is given by log-U[x1,b].</p><ul><li><code>a</code>: lower bound of the first distribution</li><li><code>b</code>: upper bound of the first distribution</li><li><code>ϵ</code>: small value to make sure that the lower and upper bounds of each distribution are different</li></ul><p>This means that the lower bound of the second distribution is dependent on the value of the first distribution. This is implemented to overcome the limitations of the current Turing&#39;s implementation for dependent priors with dynamic support. See the following issues for more details: <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/priors.jl#L82-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.TwoUniformDependent" href="#Pioran.TwoUniformDependent"><code>Pioran.TwoUniformDependent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoUniformDependent(a, b, c, ϵ)
TwoUniformDependent(a, b, c) (constructor with default ϵ = 1e-10)</code></pre><p>Multivariate distribution to model two random variables  where the first one is given by U[a,b] and the second one is given by U[x,c], where x is a random variable sampled from the first distribution.</p><ul><li><code>a</code>: lower bound of the first distribution</li><li><code>b</code>: upper bound of the first distribution</li><li><code>c</code>: upper bound of the second distribution</li><li><code>ϵ</code>: small value to make sure that the lower and upper bounds of each distribution are different</li></ul><p>This means that the lower bound of the second distribution is dependent on the value of the first distribution.This is implemented to overcome the limitations of the current Turing&#39;s implementation for dependent priors with dynamic support. See the following issues for more details: <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Pioran, Distributions
julia&gt; d = TwoUniformDependent(0, 1, 2)
TwoUniformDependent(0.0, 1.0, 2.0)

julia&gt; rand(d)
2-element Array{Float64,1}:
 0.123
 1.234</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/priors.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bijectors.bijector-Tuple{TwoUniformDependent}" href="#Bijectors.bijector-Tuple{TwoUniformDependent}"><code>Bijectors.bijector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bijectors.bijector(d::TwoUniformDependent)</code></pre><p>Create a bijector for the TwoUniformDependent distribution. This is used to sample from the distribution using the Bijectors package. Adapted from the following issues <a href="https://github.com/TuringLang/Turing.jl/issues/1558">[1]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1708">[2]</a>,<a href="https://github.com/TuringLang/Turing.jl/issues/1270">[3]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/priors.jl#L144-L149">source</a></section></article><h2 id="CARMA"><a class="docs-heading-anchor" href="#CARMA">CARMA</a><a id="CARMA-1"></a><a class="docs-heading-anchor-permalink" href="#CARMA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.CARMA" href="#Pioran.CARMA"><code>Pioran.CARMA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CARMA(p, q, rα, β, σ²)</code></pre><p>Continuous-time AutoRegressive Moving Average (CARMA) model for the power spectral density</p><ul><li><code>p</code>: the order of the autoregressive polynomial</li><li><code>q</code>: the order of the moving average polynomial</li><li><code>rα</code>: roots of the autoregressive polynomial length p+1</li><li><code>β</code>: the moving average coefficients length q+1</li><li><code>σ²</code>: the variance of the process</li></ul><p>The power spectral density of the CARMA model is given by:</p><p class="math-container">\[\mathcal{P}(f) = \sigma^2 \left|\dfrac{\sum\limits_{k=0}^q \beta_k \left(2\pi\mathrm{i}f\right)^k }{\sum\limits_{l=0}^p \alpha_l \left(2\pi\mathrm{i}f\right)^l}\right|^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/CARMA.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.quad2roots-Tuple{Any}" href="#Pioran.quad2roots-Tuple{Any}"><code>Pioran.quad2roots</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quad2roots(quad)</code></pre><p>Convert the coefficients of a quadratic polynomial to its roots.</p><p><strong>Arguments</strong></p><ul><li><code>quad::Vector{Real}</code>: Coefficients of the quadratic polynomial.</li></ul><p><strong>Returns</strong></p><ul><li><code>r::Vector{Complex}</code>: Roots of the polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/CARMA.jl#L181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pioran.roots2coeffs-Tuple{Any}" href="#Pioran.roots2coeffs-Tuple{Any}"><code>Pioran.roots2coeffs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">roots2coeffs(r)</code></pre><p>Convert the roots of a polynomial to its coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>r::Vector{Complex}</code>: Roots of the polynomial.</li></ul><p><strong>Returns</strong></p><ul><li><code>c::Vector{Complex}</code>: Coefficients of the polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlefkir/Pioran.jl/blob/6519a771f7e217b66bdac65c2dac095db6a8c038/src/CARMA.jl#L165-L175">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bibliography/">« Bibliography</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.3 on <span class="colophon-date" title="Thursday 15 May 2025 15:33">Thursday 15 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
