var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Power-spectral-densities","page":"API Reference","title":"Power spectral densities","text":"","category":"section"},{"location":"api/#Models-and-functions","page":"API Reference","title":"Models and functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"psd.jl\"]\nPrivate = false\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Pioran.DoubleBendingPowerLaw","page":"API Reference","title":"Pioran.DoubleBendingPowerLaw","text":" DoubleBendingPowerLaw(α₁, f₁, α₂, f₂, α₃)\n\nDouble bending power law model for the power spectral density\n\nα₁: the first power law index\nf₁: the first bend frequency\nα₂: the second power law index\nf₂: the second bend frequency\nα₃: the third power law index\n\nmathcalP(f) =  frac(ff₁)^-α₁1 + (f  f₁)^α₂ - α₁frac11 + (f  f₂)^α₃ - α₂\n\n\n\n\n\n","category":"type"},{"location":"api/#Pioran.DoubleBendingPowerLaw_Bis","page":"API Reference","title":"Pioran.DoubleBendingPowerLaw_Bis","text":" DoubleBendingPowerLaw_Bis(α₀, f₁, Δα₁, Δf, Δα₂)\n\nDouble bending power law model for the power spectral density\n\nα₀: the first power law index\nf₁: the first bend frequency\nΔα₁: the first difference in power law index\nΔf: scale for the second bend frequency, f₂ = f₁ * Δf\nΔα₂: the second difference in power law index\n\nmathcalP(f) =  frac(ff₁)^-α_01 + (f  f₁)^α_0+Delta α₁frac11 + (f  f₁ Delta f)^Delta α₁ + Delta α₂\n\n\n\n\n\n","category":"type"},{"location":"api/#Pioran.SingleBendingPowerLaw","page":"API Reference","title":"Pioran.SingleBendingPowerLaw","text":" SingleBendingPowerLaw(α₁, f₁, α₂)\n\nSingle bending power law model for the power spectral density\n\nα₁: the first power law index\nf₁: the first bend frequency\nα₂: the second power law index\n\nmathcalP(f) =  frac(ff₁)^-α₁1 + (f  f₁)^α₂ - α₁\n\n\n\n\n\n","category":"type"},{"location":"api/#Pioran.approx","page":"API Reference","title":"Pioran.approx","text":" approx(psd_model, f0, fM, n_components=20, var=1.0; basis_function=\"SHO\")\n\nApproximate the PSD with a sum of basis functions to form a covariance function\n\nArguments\n\npsd_model::PowerSpectralDensity: model of the PSD\nf0::Real: the lowest frequency\nfM::Real: the highest frequency\nn_components::Integer=20: the number of basis functions to use\nvar::Real=1.0: the variance of the process, integral of the PSD\nbasis_function::String=\"SHO\": the basis function to use, either \"SHO\" or \"DRWCelerite\"\n\nReturn\n\ncovariance::SumOfSemiSeparable: the covariance function\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions","page":"API Reference","title":"Helper functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"psd.jl\"]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api/#Pioran.approximated_psd-Tuple{Any, Pioran.PowerSpectralDensity, Real, Real}","page":"API Reference","title":"Pioran.approximated_psd","text":" approximated_psd(f, psd_model, f0, fM; n_components=20, var=1.0, basis_function=\"SHO\")\n\nReturn the approximated PSD. This is essentially to check that the model and the approximation are consistent.\n\nArguments\n\nf::AbstractVector{<:Real}: the frequencies at which to calculate the PSD\npsd_model::PowerSpectralDensity: model of the PSD\nf0::Real: the lowest frequency\nfM::Real: the highest frequency\nn_components::Integer=20: the number of basis functions to use\nvar::Real=1.0: the variance of the process, integral of the PSD\nbasis_function::String=\"SHO\": the basis function to use, either \"SHO\" or \"DRWCelerite\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.build_approx-Tuple{Int64, Real, Real}","page":"API Reference","title":"Pioran.build_approx","text":" build_approx(J, f0, fM; basis_function=\"SHO\")\n\nPrepare the approximation of a PSD\n\nArguments\n\nJ::Integer: the number of basis functions\nf0::Real: the lowest frequency\nfM::Real: the highest frequency\nbasis_function::String=\"SHO\": the basis function to use, either \"SHO\" or \"DRWCelerite\"\n\nReturn\n\nspectral_points::Vector{Real}: the spectral points\nspectral_matrix::Matrix{Real}: the spectral matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.calculate-Tuple{Any, DoubleBendingPowerLaw_Bis}","page":"API Reference","title":"Pioran.calculate","text":"calculate(f, psd::PowerSpectralDensity)\n\nCalculate the power spectral density at frequency f\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.get_approx_coefficients-Tuple{Pioran.PowerSpectralDensity, Real, Real}","page":"API Reference","title":"Pioran.get_approx_coefficients","text":" get_approx_coefficients(psd_model, f0, fM; n_components=20, basis_function=\"SHO\")\n\nGet the coefficients of the approximated PSD\n\nArguments\n\npsd_model::PowerSpectralDensity: model of the PSD\nf0::Real: the lowest frequency\nfM::Real: the highest frequency\nn_components::Integer=20: the number of basis functions to use\nbasis_function::String=\"SHO\": the basis function to use, either \"SHO\" or \"DRWCelerite\"\n\nReturn\n\namplitudes::Vector{Real}: the amplitudes of the basis functions\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.get_normalised_psd-Tuple{Pioran.PowerSpectralDensity, AbstractVector{<:Real}}","page":"API Reference","title":"Pioran.get_normalised_psd","text":" get_normalised_psd(psd_model::PowerSpectralDensity, spectral_points::AbstractVector{<:Real})\n\nGet the PSD normalised at the lowest frequency\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.psd_decomp-Tuple{AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"API Reference","title":"Pioran.psd_decomp","text":" psd_decomp(psd_normalised, spectral_matrix)\n\nGet amplitudes of the basis functions by solving the linear system of the approximation\n\n\n\n\n\n","category":"method"},{"location":"api/#Covariance-functions","page":"API Reference","title":"Covariance functions","text":"","category":"section"},{"location":"api/#Models-and-functions-2","page":"API Reference","title":"Models and functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"acvf.jl\",\"Exp.jl\",\"SHO.jl\",\"Celerite.jl\"]\nPrivate = false\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Pioran.Exp","page":"API Reference","title":"Pioran.Exp","text":"Exp(A,α)\n\nExponential covariance Function\n\nA: the amplitude of the covariance function\nα: the decay rate of the covariance function\n\nk(τ) = A exp(-α τ)\n\n\n\n\n\n","category":"type"},{"location":"api/#Pioran.SHO","page":"API Reference","title":"Pioran.SHO","text":" SHO(A, ω₀, Q)\n\nSimple Harmonic Oscillator covariance Function\n\nA: the amplitude of the covariance function\nω₀: the angular frequency of the covariance function\nQ: the quality factor of the covariance function\n\nk(τ) = A exp(-ω₀ τ  Q  2) leftbeginmatrix 2(1 + ω₀ τ)  Q = 12  cos(η ω₀ τ) + fracsin(η ω₀ τ)2η Q  Q  12  cosh(η ω₀ τ) + fracsinh(η ω₀ τ)2η Q  Q geq 12 endmatrixright\nη = sqrtleft1 - frac14 Q^2right\n\nSee Foreman-Mackey et al. (2017) for more details.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pioran.Celerite","page":"API Reference","title":"Pioran.Celerite","text":" Celerite(a, b, c, d)\n\nCelerite covariance Function\n\na: the amplitude of the first term\nb: the amplitude of the second term\nc: the decay rate of the covariance function\nd: the period of the covariance function\n\nk(τ) = exp(-c τ) (a cos(d τ) + b sin(d τ))\n\nSee Foreman-Mackey et al. (2017) for more details.\n\n\n\n\n\n","category":"type"},{"location":"api/#Helper-functions-2","page":"API Reference","title":"Helper functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"acvf.jl\",\"Exp.jl\",\"SHO.jl\",\"Celerite.jl\"]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api/#Base.:+-Tuple{Pioran.SemiSeparable, Pioran.SemiSeparable}","page":"API Reference","title":"Base.:+","text":" +(::SemiSeparable, ::SemiSeparable)\n\nSum of semi-separable covariance functions\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.celerite_coefs-Tuple{Pioran.SumOfSemiSeparable}","page":"API Reference","title":"Pioran.celerite_coefs","text":" celerite_coefs(covariance)\n\nGet the celerite coefficients\n\n\n\n\n\n","category":"method"},{"location":"api/#KernelFunctions.kappa-Tuple{Exp, Real}","page":"API Reference","title":"KernelFunctions.kappa","text":"Define the kernel functions for the Exp model \n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.Exp_covariance-Tuple{Any, Any, Any}","page":"API Reference","title":"Pioran.Exp_covariance","text":"Exp_covariance(τ, A, α)\n\nCompute the covariance function for an exponential with parameters σ, A at time τ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Gaussian-processes","page":"API Reference","title":"Gaussian processes","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"scalable_GP.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Pioran.ScalableGP","page":"API Reference","title":"Pioran.ScalableGP","text":"A scalable Gaussian process has a covariance function formed of semi-separable kernels\n\nSee Foreman-Mackey et al. (2017) for more details.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.rand","page":"API Reference","title":"Base.rand","text":"rand(rng::AbstractRNG, fp::PosteriorGP, N::Int=1)\nrand(rng::AbstractRNG, fp::PosteriorGP, τ::AbstractVecOrMat{<:Real}, N::Int=1)\nrand(fp::PosteriorGP, N::Int=1)\n\nSample N realisations from the posterior GP fp at the points τ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, AbstractGPs.FiniteGP{<:ScalableGP}}","page":"API Reference","title":"Base.rand","text":"rand(rng::AbstractRNG, f::ScalableGP)\nrand(rng::AbstractRNG, f::ScalableGP, t::AbstractVecOrMat{<:Real})\nrand(f::ScalableGP)\nrand(f::ScalableGP, t::AbstractVecOrMat{<:Real})\n\nDraw a realisation from the GP f at the points t.\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{AbstractGPs.FiniteGP{<:ScalableGP}, AbstractVecOrMat{<:Real}}","page":"API Reference","title":"Distributions.logpdf","text":"logpdf(f::ScalableGP, Y::AbstractVecOrMat{<:Real})\n\nCompute the log-likelihood of the data Y given the GP f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran._predict_cov-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{<:Real}}","page":"API Reference","title":"Pioran._predict_cov","text":"_predict_cov(fp::PosteriorGP, τ::AbstractVecOrMat{<:Real})\nCompute the posterior covariance of the GP at the points τ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran._predict_mean-Tuple{Pioran.PosteriorGP, AbstractVecOrMat{<:Real}}","page":"API Reference","title":"Pioran._predict_mean","text":"_predict_mean(fp::PosteriorGP, τ::AbstractVecOrMat{<:Real})\n\nCompute the Posterior mean of the GP at the points τ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.posterior-Tuple{AbstractGPs.FiniteGP{<:ScalableGP}, AbstractVecOrMat{<:Real}}","page":"API Reference","title":"Pioran.posterior","text":"posterior(f::ScalableGP, y::AbstractVecOrMat{<:Real})\n\nCompute the posterior Gaussian process fp given the GP f and the data y.\n\n\n\n\n\n","category":"method"},{"location":"api/#Solvers","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/#Celerite-solver","page":"API Reference","title":"Celerite solver","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"celerite_solver.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Pioran.init_semi_separable!-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractVector, AbstractMatrix, Matrix, AbstractMatrix}","page":"API Reference","title":"Pioran.init_semi_separable!","text":" init_semi_separable(a, b, c, d, τ, σ2)\n\nInitialise the matrices and vectors needed for the celerite algorithm. U,V are the rank-R matrices, D is the diagonal matrix and ϕ is the matrix of the exponential terms.\n\nSee Foreman-Mackey et al. (2017) for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.log_likelihood-Tuple{Pioran.SumOfSemiSeparable, Vector, Vector, Vector}","page":"API Reference","title":"Pioran.log_likelihood","text":"log_likelihood(cov, τ, y, σ2)\n\nCompute the log-likelihood of a semi-separable covariance function using the celerite algorithm.\n\nArguments\n\ncov::SumOfSemiSeparable: the covariance function\nτ::Vector: the time points\ny::Vector: the data\nσ2::Vector: the measurement variances\n\nSee Foreman-Mackey et al. (2017) for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.predict-Tuple{Pioran.SumOfSemiSeparable, Vararg{AbstractVector, 4}}","page":"API Reference","title":"Pioran.predict","text":"predict(cov, τ, t, y, σ2)\n\nCompute the posterior mean of the GP at the points τ given the data y and time t.\n\nArguments\n\ncov::SumOfSemiSeparable: the covariance function\nτ::Vector: the time points\nt::Vector: the data time points\ny::Vector: the data\nσ2::Vector: the measurement variances\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.simulate-Tuple{Random.AbstractRNG, Pioran.SumOfSemiSeparable, AbstractVector, AbstractVector}","page":"API Reference","title":"Pioran.simulate","text":"simulate(rng, cov, τ, σ2)\n\nDraw a realisation from the  GP with the covariance function cov at the points τ with the variances σ2.\n\nArguments\n\nrng::AbstractRNG: the random number generator\ncov::SumOfSemiSeparable: the covariance function\nτ::Vector: the time points\nσ2::Vector: the measurement variances\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.solve_prec!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}","page":"API Reference","title":"Pioran.solve_prec!","text":"solve_prec!(z, y, U, W, D, ϕ)\n\nForward and backward substitution of the celerite algorithm.\n\nSee Foreman-Mackey et al. (2017) for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Direct-solver","page":"API Reference","title":"Direct solver","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"direct_solver.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#Pioran.log_likelihood_direct-Tuple{KernelFunctions.SimpleKernel, Vector, Vector, Vector}","page":"API Reference","title":"Pioran.log_likelihood_direct","text":"log_likelihood_direct(cov::KernelFunctions.SimpleKernel, t::Vector, y::Vector, σ²::Vector)\n\nCompute the log-likelihood of the data Y given the GP f with the direct solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.predict_cov-Tuple{KernelFunctions.SimpleKernel, AbstractVector, AbstractVector, AbstractVector}","page":"API Reference","title":"Pioran.predict_cov","text":"predict_direct(cov::KernelFunctions.SimpleKernel, τ::AbstractVector, t::AbstractVector, σ²::AbstractVector)\n\nCompute the posterior covariance of the GP at the points τ given the times t and the noise variance σ².\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.predict_direct","page":"API Reference","title":"Pioran.predict_direct","text":"predict_direct(cov::KernelFunctions.SimpleKernel, τ::AbstractVector, t::AbstractVector, y::AbstractVector, σ²::AbstractVector, with_covariance::Bool=false)\n\nCompute the posterior mean of the GP at the points τ given the data (t, y) and the noise variance σ².\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting","page":"API Reference","title":"Plotting","text":"","category":"section"},{"location":"api/#Diagnostics","page":"API Reference","title":"Diagnostics","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"plots_diagnostics.jl\"]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api/#Pioran.run_diagnostics-NTuple{7, Any}","page":"API Reference","title":"Pioran.run_diagnostics","text":"run_diagnostics(prior_samples, variance_samples, f0, fM, model, f_min, f_max; path=\"\", basis_function=\"SHO\", n_components=20)\n\nRun the prior predictive checks for the model and the approximation of the PSD\n\nArguments\n\nprior_samples::Array{Float64, 2} : Model samples from the prior distribution\nvariance_samples::Array{Float64, 1} : The variance samples\nf0::Float64 : The minimum frequency for the approximation of the PSD\nfM::Float64 : The maximum frequency for the approximation of the PSD\nmodel::Function : The model\nf_min::Float64 : The minimum frequency of the observed data\nf_max::Float64 : The maximum frequency of the observed data\npath::String=\"\" : The path to save the plots\nbasis_function::String=\"SHO\" : The basis function for the approximation of the PSD\nn_components::Int=20 : The number of components to use for the approximation of the PSD\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.run_posterior_predict_checks-NTuple{9, Any}","page":"API Reference","title":"Pioran.run_posterior_predict_checks","text":"run_posterior_predict_checks(samples, paramnames, t, y, yerr, f0, fM, model, with_log_transform; plots=\"all\", n_samples=200, path=\"\", basis_function=\"SHO\", n_frequencies=1000, plot_f_P=false, n_components=20)\n\nRun the posterior predictive checks for the model and the approximation of the PSD\n\nArguments\n\nsamples::Array{Float64, 2} : The samples from the posterior distribution\nparamnames::Array{String, 1} : The names of the parameters\nt::Array{Float64, 1} : The time series\ny::Array{Float64, 1} : The values of the time series\nyerr::Array{Float64, 1} : The errors of the time series\nf0::Float64 : The minimum frequency for the approximation of the PSD\nfM::Float64 : The maximum frequency for the approximation of the PSD\nmodel::Function : The model\nwith_log_transform::Bool : If true, the flux is log-transformed\nplots::String or Array{String, 1} : The type of plots to make. It can be \"all\", \"psd\", \"lsp\", \"timeseries\" or a combination of them in an array\nn_samples::Int=200 : The number of samples to draw from the posterior predictive distribution\npath::String=\"all\" : The path to save the plots\nbasis_function::String=\"SHO\" : The basis function for the approximation of the PSD\nn_frequencies::Int=1000 : The number of frequencies to use for the approximation of the PSD\nplot_f_P::Bool=false : If true, the plots are made in terms of f * PSD\nn_components::Int=20 : The number of components to use for the approximation of the PSD\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.sample_approx_model-NTuple{5, Any}","page":"API Reference","title":"Pioran.sample_approx_model","text":"sample_approx_model(samples, variance_samples, f0, fM, model; n_frequencies=1_000, basis_function=\"SHO\", n_components=20)\n\nCheck the approximation of the PSD by computing the residuals and the ratios of the PSD and the approximated PSD\n\nArguments\n\nsamples::Array{Float64, n} : The model samples\nvariance_samples::Array{Float64, 1} : The variance samples\nf0::Float64 : The minimum frequency for the approximation of the PSD\nfM::Float64 : The maximum frequency for the approximation of the PSD\nmodel::Function : The model\nn_frequencies::Int=1_000 : The number of frequencies to use for the approximation of the PSD\nbasis_function::String=\"SHO\" : The basis function for the approximation of the PSD\nn_components::Int=20 : The number of components to use for the approximation of the PSD\n\nReturn\n\npsd::Array{Float64, 2} : The PSD\npsd_approx::Array{Float64, 2} : The approximated PSD\nresiduals::Array{Float64, 2} : The residuals (psd-approx_psd)\nratios::Array{Float64, 2} : The ratios (approx_psd/psd)\n\n\n\n\n\n","category":"method"},{"location":"api/#Individual-plotting-functions","page":"API Reference","title":"Individual plotting functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"plots_diagnostics.jl\"]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"api/#Pioran.get_ppc_timeseries-NTuple{11, Any}","page":"API Reference","title":"Pioran.get_ppc_timeseries","text":"get_ppc_timeseries(samples_𝓟, samples_variance, samples_ν, samples_μ, t, y, yerr,f0,fM, model,with_log_transform;samples_c=missing, n_samples=1000, path=\"\")\n\nGet the random posterior predictive time series from the model and samples \n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_boxplot_psd_approx-Tuple{Any, Any}","page":"API Reference","title":"Pioran.plot_boxplot_psd_approx","text":"plot_boxplot_psd_approx(residuals, ratios; path=\"\")\n\nPlot the boxplot of the residuals and ratios for the PSD approximation\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_lsp_ppc-NTuple{10, Any}","page":"API Reference","title":"Pioran.plot_lsp_ppc","text":"plot_lsp_ppc(samples_𝓟, samples_variance, samples_ν, samples_μ, t, y, yerr, f0, fM, model; plot_f_P=false, n_frequencies=1000, n_samples=1000, n_components=20, bin_fact=10, path=\"\", basis_function=\"SHO\")\n\nPlot the posterior predictive Lomb-Scargle periodogram of random time series from the model and samples\n\nArguments\n\nsamples_𝓟::Array{Float64, n} : The samples of the model parameters\nsamples_variance::Array{Float64, 1} : The variance samples\nsamples_ν::Array{Float64, 1} : The ν samples\nsamples_μ::Array{Float64, 1} : The μ samples\nt::Array{Float64, 1} : The time series\ny::Array{Float64, 1} : The values of the time series\nyerr::Array{Float64, 1} : The errors of the time series\nf0::Float64 : The minimum frequency for the approximation of the PSD\nfM::Float64 : The maximum frequency for the approximation of the PSD\nmodel::Function : The model\nplot_f_P::Bool=false : If true, the plot is made in terms of f * PSD\nn_frequencies::Int=1000 : The number of frequencies to use for the approximation of the PSD\nn_samples::Int=1000 : The number of samples to draw from the posterior predictive distribution\nn_components::Int=20 : The number of components to use for the approximation of the PSD\nbin_fact::Int=10 : The binning factor for the LSP\npath::String=\"\" : The path to save the plots\nbasis_function::String=\"SHO\" : The basis function for the approximation of the PSD\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_mean_approx-Tuple{Any, Any, Any}","page":"API Reference","title":"Pioran.plot_mean_approx","text":"plot_mean_approx(f, residuals, ratios; path=\"\")\n\nPlot the frequency-averaged residuals and ratios\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_ppc_timeseries-NTuple{11, Any}","page":"API Reference","title":"Pioran.plot_ppc_timeseries","text":"plot_ppc_timeseries(samples_𝓟, samples_variance, samples_ν, samples_μ, t, y, yerr, f0, fM, model, with_log_transform; t_pred=nothing, samples_c=nothing, n_samples=100, n_components=20, basis_function=\"SHO\", path=\"\")\n\nPlot the posterior predictive time series and the residuals \n\nArguments\n\nsamples_𝓟::Matrix{Float64} : The samples of the model parameters\nsamples_variance::Vector{Float64} : The variance samples\nsamples_ν::Vector{Float64} : The noise level samples\nsamples_μ::Vector{Float64} : The mean samples\nt::Vector{Float64} : The time series\ny::Vector{Float64} : The values of the time series\nyerr::Vector{Float64} : The errors of the time series\nf0::Float64 : The minimum frequency for the approximation of the PSD\nfM::Float64 : The maximum frequency for the approximation of the PSD\nmodel::PowerSpectralDensity : The model\nwith_log_transform::Bool : If true, the flux was log-transformed for the inference\nt_pred::Vector{Float64}=nothing : The prediction times\nsamples_c::Vector{Float64}=nothing : The samples of the constant (if the flux was log-transformed)\nn_samples::Int=100 : The number of samples to draw from the posterior predictive distribution\nn_components::Int=20 : The number of components to use for the approximation of the PSD\nbasis_function::String=\"SHO\" : The basis function for the approximation of the PSD\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_psd_ppc-NTuple{8, Any}","page":"API Reference","title":"Pioran.plot_psd_ppc","text":"plot_psd_ppc(samples_𝓟, samples_variance, samples_ν, t, yerr, f0, fM, model; plot_f_P=false, n_frequencies=1000, path=\"\", n_components=20, basis_function=\"SHO\")\n\nPlot the posterior predictive power spectral density and the noise levels\n\nArguments\n\nsamples_𝓟::Array{Float64, n} : The samples of the model parameters\nsamples_variance::Array{Float64, 1} : The variance samples\nsamples_ν::Array{Float64, 1} : The ν samples\nt::Array{Float64, 1} : The time series\nyerr::Array{Float64, 1} : The errors of the time series\nf0::Float64 : The minimum frequency for the approximation of the PSD\nfM::Float64 : The maximum frequency for the approximation of the PSD\nmodel::Function : The model\nplot_f_P::Bool=false : If true, the plot is made in terms of f * PSD\nn_frequencies::Int=1000 : The number of frequencies to use for the approximation of the PSD\nn_components::Int=20 : The number of components to use for the approximation of the PSD\nbasis_function::String=\"SHO\" : The basis function for the approximation of the PSD\npath::String=\"\" : The path to save the plots\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_quantiles_approx-NTuple{5, Any}","page":"API Reference","title":"Pioran.plot_quantiles_approx","text":"plot_quantiles_approx(f, f_min, f_max, residuals, ratios; path=\"\")\n\nPlot the quantiles of the residuals and ratios (with respect to the approximated PSD) of the PSD \n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_residuals_diagnostics-Tuple{Any, Any, Any}","page":"API Reference","title":"Pioran.plot_residuals_diagnostics","text":"plot_residuals_diagnostics(t, mean_res, res_quantiles; confidence_intervals=[95, 99], path=\"\")\n\nPlot the residuals and the autocorrelation function of the residuals \n\nArguments\n\nt::Vector{Float64} : The time series\nmean_res::Vector{Float64} : The mean of the residuals\nres_quantiles::Array{Float64, 2} : The quantiles of the residuals\nconfidence_intervals::Array{Int, 1} : The confidence intervals\npath::String=\"\" : The path to save the plot\n\n\n\n\n\n","category":"method"},{"location":"api/#Pioran.plot_simu_ppc_timeseries-NTuple{5, Any}","page":"API Reference","title":"Pioran.plot_simu_ppc_timeseries","text":"plot_simu_ppc_timeseries(t_pred, ts_quantiles, t, y, yerr; path=\"\")\n\nPlot the posterior predictive simulated time series\n\nArguments\n\nt_pred::Vector{Float64} : The prediction times\nts_quantiles::Array{Float64, 2} : The quantiles of the posterior predictive time series\nt::Vector{Float64} : The time series\ny::Vector{Float64} : The values of the time series\nyerr::Vector{Float64} : The errors of the time series\npath::String=\"\" : The path to save the plot\n\n\n\n\n\n","category":"method"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [Pioran]\nPages = [\"utilities.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"ultranest/#Inference-with-ultranest","page":"Inference with ultranest","title":"Inference with ultranest","text":"","category":"section"},{"location":"ultranest/#Installation","page":"Inference with ultranest","title":"Installation","text":"","category":"section"},{"location":"ultranest/","page":"Inference with ultranest","title":"Inference with ultranest","text":"With MPI","category":"page"},{"location":"ultranest/#Modelling","page":"Inference with ultranest","title":"Modelling","text":"","category":"section"},{"location":"ultranest/#Example-script","page":"Inference with ultranest","title":"Example script","text":"","category":"section"},{"location":"diagnostics/#Diagnostics-post-inference","page":"Diagnostics post-inference","title":"Diagnostics post-inference","text":"","category":"section"},{"location":"diagnostics/#Introduction","page":"Diagnostics post-inference","title":"Introduction","text":"","category":"section"},{"location":"diagnostics/#In-the-time-domain","page":"Diagnostics post-inference","title":"In the time domain","text":"","category":"section"},{"location":"diagnostics/#In-the-frequency-domain","page":"Diagnostics post-inference","title":"In the frequency domain","text":"","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As Pioran is written in Julia, you need to install Julia first. Please refer to the official website for the installation.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once Julia is installed, you can install Pioran by running the following command in the Julia REPL:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"] add Pioran","category":"page"},{"location":"getting_started/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pioran","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Assuming you have a time series y  indexed by t and with measurement noise yerr","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using DelimitedFiles\nusing Plots\nA = readdlm(\"data/simu.txt\",comments=true)\nt, y, yerr = A[:,1], A[:,2], A[:,3]\nσ² = yerr .^ 2 \n\n\nscatter(t, y,yerr=yerr, label=\"data\",xlabel=\"Time (days)\",ylabel=\"Value\",legend=false,framestyle = :box,ms=3)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's assume we can model power spectrum with a single bending power-law.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"α₁, f₁, α₂ = 0.3, 0.03, 3.2\n𝓟 = SingleBendingPowerLaw(α₁, f₁, α₂)\nf = 10 .^ range(-3, stop=3, length=1000)\nplot(f, 𝓟.(f), label=\"Single Bending Power Law\",xlabel=\"Frequency (day^-1)\",ylabel=\"Power Spectral Density\",legend=true,framestyle = :box,xscale=:log10,yscale=:log10)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To compute the corresponding covariance function, we approximate the power spectral density by a sum of SHO power spectral densities.  We need to specify the frequency range f0 and fM over which the approximation is performed. The variance of the process - integral of the power spectrum can also be given.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"f0, fM = 1e-3, 1e3\nvariance = 12.3  \n𝓡 = approx(𝓟, f0, fM, 20, variance, basis_function=\"SHO\")\nτ = range(0, stop=300, length=1000)\nplot(τ, 𝓡.(τ,0.), label=\"Covariance function\",xlabel=\"Time lag (days)\",ylabel=\"Autocovariance\",legend=true,framestyle = :box)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can now build a Gaussian process f which uses the quasi-separable struct of the covariance function to speed up the computations. If the mean of the process mu is known, it can be given as an argument. Otherwise, the mean is assumed to be zero.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"μ = 1.3\nf = ScalableGP(μ, 𝓡)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can obtain the log-likelihood of the Gaussian process given the data and the measurement noise using the function logpdf from the Distributions package.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Distributions\nlogpdf(f(t, σ²), y)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can combine all these steps in a single function to compute the log-likelihood of the data given the parameters of the power spectral density and the Gaussian process.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"\nfunction loglikelihood(y, t, σ, params)\n\n    α₁, f₁, α₂, variance, ν, μ = params\n\n    # Rescale the measurement variance\n    σ² = ν .* σ .^ 2 \n\n    # Define power spectral density function\n    𝓟 = SingleBendingPowerLaw(α₁, f₁, α₂)\n\n    # Approximation of the PSD to form a covariance function\n    𝓡 = approx(𝓟, f0, fM, 20, variance, basis_function=\"SHO\")\n\n    # Build the GP\n    f = ScalableGP(μ, 𝓡)\n\n    # sample the conditioned distribution\n    return logpdf(f(t, σ²), y)\nend","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Time-series","page":"Examples","title":"Time series","text":"","category":"section"},{"location":"examples/#Log-normally-distributed-time-series","page":"Examples","title":"Log-normally distributed time series","text":"","category":"section"},{"location":"turing/#Inference-with-Turing.jl","page":"Inference with Turing.jl","title":"Inference with Turing.jl","text":"","category":"section"},{"location":"turing/#Modelling-function","page":"Inference with Turing.jl","title":"Modelling function","text":"","category":"section"},{"location":"turing/#Distributed-sampling","page":"Inference with Turing.jl","title":"Distributed sampling","text":"","category":"section"},{"location":"turing/#Example:-Gaussian-process-regression","page":"Inference with Turing.jl","title":"Example: Gaussian process regression","text":"","category":"section"},{"location":"explanation/#Gaussian-processes","page":"Gaussian processes","title":"Gaussian processes","text":"","category":"section"},{"location":"explanation/#Introduction","page":"Gaussian processes","title":"Introduction","text":"","category":"section"},{"location":"explanation/","page":"Gaussian processes","title":"Gaussian processes","text":"gp and psd, acvf","category":"page"},{"location":"explanation/#Gaussian-processes-in-Pioran","page":"Gaussian processes","title":"Gaussian processes in Pioran","text":"","category":"section"},{"location":"explanation/","page":"Gaussian processes","title":"Gaussian processes","text":"approximtiom, scalable... AbstractGPs ...","category":"page"},{"location":"explanation/#References","page":"Gaussian processes","title":"References","text":"","category":"section"},{"location":"explanation/","page":"Gaussian processes","title":"Gaussian processes","text":"Rassmusen, C. E., & Williams, C. K. I. (2006). Gaussian Processes for Machine Learning. MIT Press. F2017","category":"page"},{"location":"modelling/#Modelling","page":"Modelling","title":"Modelling","text":"","category":"section"},{"location":"modelling/","page":"Modelling","title":"Modelling","text":"PSD ","category":"page"},{"location":"modelling/#Bending-power-laws","page":"Modelling","title":"Bending power-laws","text":"","category":"section"},{"location":"modelling/","page":"Modelling","title":"Modelling","text":"single,double power-law","category":"page"},{"location":"modelling/#Approximation","page":"Modelling","title":"Approximation","text":"","category":"section"},{"location":"modelling/","page":"Modelling","title":"Modelling","text":"diagnostics pre-inference","category":"page"},{"location":"#Pioran","page":"Home","title":"Pioran","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pioran is a Julia package for the inference of power spectra from arbitrary sampled time series. It the twin package of the eponymous Python package pioran.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"Pioran\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = vcat([\"getting_started.md\"],Main.BASIC_PAGES,Main.ADVANCED_PAGES,[\"api.md\"])\nDepth = 2","category":"page"}]
}
